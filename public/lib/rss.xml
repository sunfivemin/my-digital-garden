<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.ico</url><title>blog</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 17 Apr 2025 12:20:35 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 17 Apr 2025 12:20:34 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[📘 2025-04-17 TIL]]></title><description><![CDATA[ 
 <br><br><br>
<br>map object
<br>Express와 Map을 활용한 간단한 API 만들기
<br>express 구조 이해해보기
<br><br><br><br>const db = new Map();
db.set(1, "NoteBook");
db.set(2, "Cup");
db.set(3, "Chair");
<br>
<br>이처럼 문자열 데이터를 저장하는 방식도 가능하지만, 아래처럼 객체를 값(value) 으로 넣는 게 실제 API를 만들때 확장 가능한 구조로 만들 수 있다.
<br>객체를 value로 저장하면 응답 구조도 깔끔하고 유지보수도 쉬워진다.
<br><br>const notebook = { productName: "Notebook", price: 2000000 };
const cup = { productName: "Cup", price: 3000 };
const chair = { productName: "Chair", price: 100000 };
const poster = { productName: "Poster", price: 20000 };

const db = new Map();
db.set(1, notebook);
db.set(2, cup);
db.set(3, chair);
db.set(4, poster);
<br>console.log(db.get(1)); 
// 👉 { productName: 'Notebook', price: 2000000 }

console.log(db.get(3)); 
// 👉 { productName: 'Chair', price: 100000 }
<br>→ Map을 통해 숫자 key로 접근해도, 객체 전체를 값으로 받아볼 수 있다.<br><br><br><br>app.get("/:id", function (req, res) {
  let { id } = req.params; //  URL 파라미터로부터 id 추출
  const numericId = parseInt(id); // URL에서 전달된 id를 꺼내고 숫자로 변환
  const product = db.get(numericId); //Map에서 해당 상품을 조회하고 로그 출력

  if (db.get(numericId) == undefined) {
    res.json({
      message: "없는 상품입니다",
    });
  } else {
    product.id = numericId;
    res.json(product);
  }
});
<br><br>const express = require("express");
const app = express();

app.listen(1234);

let youtuber1 = {
  channelTitle: "105ya",
  sub: "593만명",
  videoNum: "999개",
};

let youtuber2 = {
  channelTitle: "침펄맨",
  sub: "1593만명",
  videoNum: "5699개",
};

let youtuber3 = {
  channelTitle: "테오",
  sub: "93만명",
  videoNum: "99개",
};

let db = new Map();
db.set(1, youtuber1);
db.set(2, youtuber2);
db.set(3, youtuber3);

app.get("/youtuber/:id", function (req, res) {
  let { id } = req.params;
  const numericId = parseInt(id);
  const youtuber = db.get(numericId);

  if (!youtuber) {
    res.json({
      message: "없는 youtuber입니다.",
    });
  } else {
    youtuber.id = numericId;
    res.json(youtuber);
  }
});
<br><img alt="expressmap" src="https://seonohblog.netlify.app/assets/expressmap.png" referrerpolicy="no-referrer"><br>
<br>Map 객체를 이용해 유튜버 데이터를 ID별로 저장하고,
<br>Express를 통해 RESTful한 조회 API를 간단히 만들 수 있다.
<br>응답 구조를 명확히 하고, 없는 데이터에 대한 처리도 추가해줘야 실전에서 안정적인 API 설계가 가능하다.
<br><br>Node.js + Express 프로젝트를 만들다 보면, 다음과 같은 구조로 파일을 분리하는 걸 자주 보게 된다:<br>my-express-app/
├── app.js              # Express 앱 생성 및 미들웨어 설정
├── bin/
│   └── www             # 서버 실행 스크립트
├── routes/
│   └── index.js        # 라우터 모음
├── public/             # 정적 파일 (이미지, CSS, JS)
├── views/              # 템플릿 엔진을 사용하는 경우 뷰 파일 저장
├── package.json        # 프로젝트 메타 정보 및 의존성
<br>이 구조는 Express에서 기본적으로 제공하는 방식이기도 하며, 프로젝트가 커질수록 이 구조가 굉장히 유용해진다.<br><br><br>const express = require("express");
const app = express();
const indexRouter = require("./routes/index");

// 미들웨어 등록
app.use(express.json()); // JSON 바디 파싱
app.use(express.urlencoded({ extended: true })); // 폼데이터 파싱

// 정적 파일 서비스
app.use(express.static("public"));

// 라우터 연결
app.use("/", indexRouter);

// 앱 모듈 내보내기
module.exports = app;
<br>
<br>express()로 앱 인스턴스를 만들고,
<br>필요한 라우터와 미들웨어를 연결한다.
<br>module.exports = app; 으로 외부에서도 이 앱을 사용할 수 있도록 내보낸다.
<br>이 파일이 앱의 중심 허브 역할을 한다.
<br><br><br>#!/usr/bin/env node

const app = require("../app");
const http = require("http");

const port = 1234;
app.set("port", port);

const server = http.createServer(app);
server.listen(port, () =&gt; {
  console.log(`✅ 서버 실행됨: http://localhost:${port}`);
});
<br>
<br>www 파일은 서버를 실행만 하는 용도로, HTTP 서버 객체를 생성하고 app.js를 실행시킨다.
<br>이렇게 분리하면, 서버 실행과 앱 설정을 깔끔하게 구분할 수 있다.
<br>실무에서 npm start는 보통 이 www 파일을 실행시켜 서버를 띄운다.
<br><br><br>const express = require("express");
const router = express.Router();

router.get("/", (req, res) =&gt; {
  res.send("Hello Express!");
});

router.get("/health", (req, res) =&gt; {
  res.json({ status: "OK" });
});

module.exports = router;
<br>
<br>router.get() 등을 통해 라우팅 로직을 모듈화할 수 있다.
<br>이 파일은 app.js에서 require("./routes/index") 형태로 불러와 연결된다.
<br>실무에서는 routes/products.js, routes/users.js처럼 기능별로 더 잘게 나눠 사용한다.
<br><img alt="express9999" src="https://seonohblog.netlify.app/assets/express9999.png" referrerpolicy="no-referrer"><br><br><br>• 새롭게 알게 된 점<br>
<br>JavaScript의 Map 객체를 사용하면 단순 문자열뿐 아니라 객체도 값으로 저장할 수 있어 확장성이 뛰어나다는 것을 알게 됐다.
<br>Express에서는 데이터를 저장하거나 응답할 때 Map을 잘 활용하면 코드가 간결하고 유지보수가 쉬워진다.
<br>Express 앱은 app.js, www, routes/ 등으로 파일을 분리해서 구성할 수 있으며, 이 구조는 실무에서도 자주 사용하는 표준 구조라는 점이 인상 깊었다.
<br>• 어렵게 느껴졌던 부분<br>
<br>처음에는 브라우저에서 Cannot GET /1 에러가 왜 발생하는지 이해하는 데 시간이 걸렸다. 알고 보니 라우팅 경로를 /youtuber/:id로 지정했기 때문에 정확한 경로로 요청해야 했다.
<br>favicon.ico 요청처럼 브라우저가 자동으로 보내는 요청을 처음엔 예상하지 못해 로그가 이상하게 출력되는 원인을 찾는 게 살짝 헷갈렸다.
<br>www와 app.js의 역할 구분이 처음엔 애매하게 느껴졌지만, 직접 실행 구조를 따라가보며 조금씩 감이 잡혔다.
<br>• 다음에 학습할 주제<br>
<br>POST 메서드를 이용한 데이터 등록 기능 구현
<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank">MDN Web Docs - Map 객체</a>
<br><a data-tooltip-position="top" aria-label="https://expressjs.com/ko/" rel="noopener nofollow" class="external-link" href="https://expressjs.com/ko/" target="_blank">Express 공식 문서 (Express.js Guide)</a>
<br><a data-tooltip-position="top" aria-label="https://nodejs.org/ko/docs" rel="noopener nofollow" class="external-link" href="https://nodejs.org/ko/docs" target="_blank">Node.js 공식 문서</a>
]]></description><link>4.til/4월/2025-04-17-map.html</link><guid isPermaLink="false">4.TIL/4월/2025-04-17-Map.md</guid><pubDate>Thu, 17 Apr 2025 12:20:20 GMT</pubDate><enclosure url="https://seonohblog.netlify.app/assets/expressmap.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://seonohblog.netlify.app/assets/expressmap.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📘 2025-04-18 TIL]]></title><description><![CDATA[ 
 <br><br><br>
<br>map object
<br><br><br><br>const db = new Map();
db.set(1, "NoteBook");
db.set(2, "Cup");
db.set(3, "Chair");
<br>
<br>이처럼 문자열 데이터를 저장하는 방식도 가능하지만, 아래처럼 객체를 값(value) 으로 넣는 게 실제 API를 만들때 확장 가능한 구조로 만들 수 있다.
<br>객체를 value로 저장하면 응답 구조도 깔끔하고 유지보수도 쉬워진다.
<br><img alt="express9999" src="https://seonohblog.netlify.app/assets/express9999.png" referrerpolicy="no-referrer"><br><br><br>• 새롭게 알게 된 점<br>
<br>JavaScript의 Map 객체를 사용하면 단순 문자열뿐 아니라 객체도 값으로 저장할 수 있어 확장성이 뛰어나다는 것을 알게 됐다.
<br>Express에서는 데이터를 저장하거나 응답할 때 Map을 잘 활용하면 코드가 간결하고 유지보수가 쉬워진다.
<br>Express 앱은 app.js, www, routes/ 등으로 파일을 분리해서 구성할 수 있으며, 이 구조는 실무에서도 자주 사용하는 표준 구조라는 점이 인상 깊었다.
<br>• 어렵게 느껴졌던 부분<br>
<br>처음에는 브라우저에서 Cannot GET /1 에러가 왜 발생하는지 이해하는 데 시간이 걸렸다. 알고 보니 라우팅 경로를 /youtuber/:id로 지정했기 때문에 정확한 경로로 요청해야 했다.
<br>favicon.ico 요청처럼 브라우저가 자동으로 보내는 요청을 처음엔 예상하지 못해 로그가 이상하게 출력되는 원인을 찾는 게 살짝 헷갈렸다.
<br>www와 app.js의 역할 구분이 처음엔 애매하게 느껴졌지만, 직접 실행 구조를 따라가보며 조금씩 감이 잡혔다.
<br>• 다음에 학습할 주제<br>
<br>POST 메서드를 이용한 데이터 등록 기능 구현
<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://expressjs.com/ko/guide/routing.html" rel="noopener nofollow" class="external-link" href="https://expressjs.com/ko/guide/routing.html" target="_blank">Express 공식 문서</a>
]]></description><link>4.til/4월/2025-04-18-postman.html</link><guid isPermaLink="false">4.TIL/4월/2025-04-18-Postman.md</guid><pubDate>Thu, 17 Apr 2025 12:11:16 GMT</pubDate><enclosure url="https://seonohblog.netlify.app/assets/express9999.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://seonohblog.netlify.app/assets/express9999.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📘 2025-04-17 TIL]]></title><description><![CDATA[ 
 <br><br><br>
<br>map object
<br><br><br><br>const db = new Map();
db.set(1, "NoteBook");
db.set(2, "Cup");
db.set(3, "Chair");
<br>
<br>이처럼 문자열 데이터를 저장하는 방식도 가능하지만, 아래처럼 객체를 값(value) 으로 넣는 게 실제 API를 만들때 확장 가능한 구조로 만들 수 있다.
<br>객체를 value로 저장하면 응답 구조도 깔끔하고 유지보수도 쉬워진다.
<br><br>const notebook = { productName: "Notebook", price: 2000000 };
const cup = { productName: "Cup", price: 3000 };
const chair = { productName: "Chair", price: 100000 };
const poster = { productName: "Poster", price: 20000 };

const db = new Map();
db.set(1, notebook);
db.set(2, cup);
db.set(3, chair);
db.set(4, poster);
<br>console.log(db.get(1)); 
// 👉 { productName: 'Notebook', price: 2000000 }

console.log(db.get(3)); 
// 👉 { productName: 'Chair', price: 100000 }
<br>→ Map을 통해 숫자 key로 접근해도, 객체 전체를 값으로 받아볼 수 있다.<br><br><br><br>app.get("/:id", function (req, res) {
  let { id } = req.params; //  URL 파라미터로부터 id 추출
  const numericId = parseInt(id); // URL에서 전달된 id를 꺼내고 숫자로 변환
  const product = db.get(numericId); //Map에서 해당 상품을 조회하고 로그 출력

  if (db.get(numericId) == undefined) {
    res.json({
      message: "없는 상품입니다",
    });
  } else {
    product.id = numericId;
    res.json(product);
  }
});
<br><br>const express = require("express");
const app = express();

app.listen(1234);

let youtuber1 = {
  channelTitle: "105ya",
  sub: "593만명",
  videoNum: "999개",
};

let youtuber2 = {
  channelTitle: "침펄맨",
  sub: "1593만명",
  videoNum: "5699개",
};

let youtuber3 = {
  channelTitle: "테오",
  sub: "93만명",
  videoNum: "99개",
};

let db = new Map();
db.set(1, youtuber1);
db.set(2, youtuber2);
db.set(3, youtuber3);

app.get("/youtuber/:id", function (req, res) {
  let { id } = req.params;
  const numericId = parseInt(id);
  const youtuber = db.get(numericId);

  if (!youtuber) {
    res.json({
      message: "없는 youtuber입니다.",
    });
  } else {
    youtuber.id = numericId;
    res.json(youtuber);
  }
});
<br><img alt="ExpressMap" src="https://seonohblog.netlify.app/assets/ExpressMap.png" referrerpolicy="no-referrer"><br>
<br>Map 객체를 이용해 유튜버 데이터를 ID별로 저장하고,
<br>Express를 통해 RESTful한 조회 API를 간단히 만들 수 있다.
<br>응답 구조를 명확히 하고, 없는 데이터에 대한 처리도 추가해줘야 실전에서 안정적인 API 설계가 가능하다.
<br><br>Node.js + Express 프로젝트를 만들다 보면, 다음과 같은 구조로 파일을 분리하는 걸 자주 보게 된다:<br>my-express-app/
├── app.js              # Express 앱 생성 및 미들웨어 설정
├── bin/
│   └── www             # 서버 실행 스크립트
├── routes/
│   └── index.js        # 라우터 모음
├── public/             # 정적 파일 (이미지, CSS, JS)
├── views/              # 템플릿 엔진을 사용하는 경우 뷰 파일 저장
├── package.json        # 프로젝트 메타 정보 및 의존성
<br>이 구조는 Express에서 기본적으로 제공하는 방식이기도 하며, 프로젝트가 커질수록 이 구조가 굉장히 유용해진다.<br><br><br>const express = require("express");
const app = express();
const indexRouter = require("./routes/index");

// 미들웨어 등록
app.use(express.json()); // JSON 바디 파싱
app.use(express.urlencoded({ extended: true })); // 폼데이터 파싱

// 정적 파일 서비스
app.use(express.static("public"));

// 라우터 연결
app.use("/", indexRouter);

// 앱 모듈 내보내기
module.exports = app;
<br>
<br>express()로 앱 인스턴스를 만들고,
<br>필요한 라우터와 미들웨어를 연결한다.
<br>module.exports = app; 으로 외부에서도 이 앱을 사용할 수 있도록 내보낸다.
<br>이 파일이 앱의 중심 허브 역할을 한다.
<br><br><br>#!/usr/bin/env node

const app = require("../app");
const http = require("http");

const port = 1234;
app.set("port", port);

const server = http.createServer(app);
server.listen(port, () =&gt; {
  console.log(`✅ 서버 실행됨: http://localhost:${port}`);
});
<br>
<br>www 파일은 서버를 실행만 하는 용도로, HTTP 서버 객체를 생성하고 app.js를 실행시킨다.
<br>이렇게 분리하면, 서버 실행과 앱 설정을 깔끔하게 구분할 수 있다.
<br>실무에서 npm start는 보통 이 www 파일을 실행시켜 서버를 띄운다.
<br><br><br>const express = require("express");
const router = express.Router();

router.get("/", (req, res) =&gt; {
  res.send("Hello Express!");
});

router.get("/health", (req, res) =&gt; {
  res.json({ status: "OK" });
});

module.exports = router;
<br>
<br>router.get() 등을 통해 라우팅 로직을 모듈화할 수 있다.
<br>이 파일은 app.js에서 require("./routes/index") 형태로 불러와 연결된다.
<br>실무에서는 routes/products.js, routes/users.js처럼 기능별로 더 잘게 나눠 사용한다.
<br><img alt="express9999" src="https://seonohblog.netlify.app/assets/express9999.png" referrerpolicy="no-referrer"><br><br><br>• 새롭게 알게 된 점<br>
<br>JavaScript의 Map 객체를 사용하면 단순 문자열뿐 아니라 객체도 값으로 저장할 수 있어 확장성이 뛰어나다는 것을 알게 됐다.
<br>Express에서는 데이터를 저장하거나 응답할 때 Map을 잘 활용하면 코드가 간결하고 유지보수가 쉬워진다.
<br>Express 앱은 app.js, www, routes/ 등으로 파일을 분리해서 구성할 수 있으며, 이 구조는 실무에서도 자주 사용하는 표준 구조라는 점이 인상 깊었다.
<br>• 어렵게 느껴졌던 부분<br>
<br>처음에는 브라우저에서 Cannot GET /1 에러가 왜 발생하는지 이해하는 데 시간이 걸렸다. 알고 보니 라우팅 경로를 /youtuber/:id로 지정했기 때문에 정확한 경로로 요청해야 했다.
<br>favicon.ico 요청처럼 브라우저가 자동으로 보내는 요청을 처음엔 예상하지 못해 로그가 이상하게 출력되는 원인을 찾는 게 살짝 헷갈렸다.
<br>www와 app.js의 역할 구분이 처음엔 애매하게 느껴졌지만, 직접 실행 구조를 따라가보며 조금씩 감이 잡혔다.
<br>• 다음에 학습할 주제<br>
<br>POST 메서드를 이용한 데이터 등록 기능 구현
<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://expressjs.com/ko/guide/routing.html" rel="noopener nofollow" class="external-link" href="https://expressjs.com/ko/guide/routing.html" target="_blank">Express 공식 문서</a>
]]></description><link>4.til/4월/2025-04-17-postman.html</link><guid isPermaLink="false">4.TIL/4월/2025-04-17-Postman.md</guid><pubDate>Thu, 17 Apr 2025 12:08:10 GMT</pubDate><enclosure url="https://seonohblog.netlify.app/assets/ExpressMap.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://seonohblog.netlify.app/assets/ExpressMap.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📘 2025-04-02 TIL]]></title><description/></item></channel></rss>