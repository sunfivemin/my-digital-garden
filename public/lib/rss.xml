<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 166 at column 468: Invalid bytes in character encoding
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.ico</url><title>blog</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 05 Jun 2025 13:47:28 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 05 Jun 2025 13:47:13 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[🎨 실무에서 통하는 디자인 시스템 설계와 Storybook 활용법]]></title><description><![CDATA[ 
 <br><br>React 프로젝트를 진행하다 보면 자연스럽게 드는 생각이 하나 있어요.<br>
“공통 UI 요소가 자꾸 반복되는데, 좀 더 체계적으로 정리할 수 없을까?”<br>
이때 필요한 게 바로 디자인 시스템입니다. 그리고 이를 문서화하고 테스트할 수 있는 최고의 도구는 바로 Storybook이죠.<br>이번 글에서는 디자인 시스템을 왜 쓰는지부터, 어떻게 구성하면 실무에 유리한지, 그리고 Storybook을 통해 어떻게 문서화하고 협업까지 연결할 수 있는지를 정리해봤어요.<br><br><br>디자인 시스템은 일관된 UI/UX를 제공하기 위한 설계 기준이에요.<br>
예를 들어 팀원들이 만든 버튼이 다 제각각이면 유지보수도 어렵고 사용자 경험도 들쑥날쑥하죠.<br>
이런 문제를 막기 위해 공통 컴포넌트, 스타일 가이드, 디자인 토큰 등을 하나로 정리한 시스템이 필요합니다.<br>
<br>버튼, 인풋, 카드 같은 공통 컴포넌트
<br>컬러, 폰트, 여백 같은 스타일 기준값 (디자인 토큰)
<br>사용법과 예제, 문서화
<br>이런 것들을 미리 정리해두면 개발도 빨라지고, 유지보수도 쉬워지고, 협업도 편해집니다.<br><br>
<br>디자이너와 협업 시 Figma 토큰을 기준으로 개발자가 변환해서 코드에 반영
<br>컴포넌트가 중복되지 않도록 공유된 디자인 토큰 기반으로 개발
<br>새로운 페이지가 생겨도 공통 컴포넌트 조합만으로 빠르게 개발 가능
<br>팀 규모가 커질수록 Storybook을 내부 개발자용 UI 가이드로 배포
<br><br><br>토큰과 컴포넌트를 분리해두면 규모가 커져도 정리가 잘 돼요.<br>src/
├── components/         # Button, Input, Card 등 공통 UI 컴포넌트
├── designSystem/
│   ├── tokens/         # 색상, 타이포, 여백 등 디자인 토큰
│   │   ├── colors.js
│   │   ├── spacing.js
│   │   └── typography.js
│   └── index.js        # 모든 토큰 모듈화
├── pages/              # 실제 페이지 단위 컴포넌트
└── App.jsx
<br><br><br>디자인 토큰은 스타일 기준값을 변수처럼 관리하는 것이에요.<br>
한 번만 정의해두면, 나중에 전체 테마 바꾸기도 편하고, 디자이너 피드백 반영도 훨씬 수월해요.<br>// designSystem/tokens/colors.js
export const colors = {
  primary: "#3B82F6", // Tailwind blue-500
  secondary: "#F3F4F6",
  danger: "#EF4444",
  text: "#1F2937",
};

// designSystem/tokens/typography.js
export const fontSize = {
  sm: "0.875rem",
  base: "1rem",
  xl: "1.25rem",
};

<br><br><br>variant, icon, disabled 같은 props도 추가해두면 더 유연한 컴포넌트가 됩니다.<br>// components/Button.jsx
import { colors } from "../designSystem/tokens/colors";

export default function Button({ label, onClick, variant = "primary" }) {
  const style = {
    backgroundColor: colors[variant],
    color: "#fff",
    padding: "8px 16px",
    borderRadius: "8px",
    fontSize: "0.875rem",
  };

  return &lt;button onClick={onClick} style={style}&gt;{label}&lt;/button&gt;;
}
<br><br><br>Storybook은 컴포넌트를 독립적으로 개발하고 테스트할 수 있도록 해주는 도구예요.<br>
디자이너, 기획자, QA가 개발 서버를 보지 않고도 UI 상태를 확인할 수 있게 해주죠.<br>
Docs 탭, Controls, Canvas를 통해 컴포넌트의 상태와 props를 바로 확인하고 테스트할 수 있어요.<br>Storybook에서는<br>
<br>컴포넌트 상태별 stories 작성 (Primary, Disabled, WithIcon 등)
<br>Docs 탭: 컴포넌트 사용 방법과 &nbsp;UI 상태 등을 문서처럼 자동 정리
<br>Controls 탭: props 값을 직접 조절해보면서 테스트 가능
<br>npx storybook init
npm run storybook
<br>// Button.stories.jsx
import Button from "./Button";

export default {
  title: "Components/Button",
  component: Button,
};

export const Primary = {
  args: {
    label: "확인",
    variant: "primary",
  },
};

<br><br><br>
<br>디자인 시스템이 있는 회사에서는 Figma 디자인 → 토큰으로 변환 → 컴포넌트에 적용
<br>Storybook을 통해 팀원들에게 공통 UI를 보여주고 가이드라인처럼 활용
<br>규모가 클수록, 팀원이 많을수록 디자인 시스템과 Storybook은 필수예요
<br>배포된 Storybook은 퍼블릭 문서처럼 외부에 공개할 수도 있고, 디자인 QA에도 유용해요.
<br><br><br><br>
<br>GitHub Pages / Vercel / Netlify에 정적 사이트로 배포 가능
<br>storybook-static 폴더를 GitHub Actions로 자동 배포
<br>디자이너나 팀원에게 배포된 링크로 컴포넌트 가이드를 제공
<br>.storybook 폴더 내 설정을 정리해 build-storybook 명령어로 HTML 생성
<br>npm run build-storybook
<br><br>
<br>Figma에서 디자인 토큰을 export → style-dictionary로 변환 → 코드 자동 생성 가능
<br>CSS 변수 → JS 모듈로 변환
<br>혹은 Tailwind의 theme.extend에 직접 바인딩
<br>테마를 여러 개로 나눠도 유지보수가 쉬워짐
<br>이렇게 하면 디자이너가 디자인을 바꾸면, 바로 코드에 반영되도록 자동화할 수 있어요.<br><br><br>처음엔 ‘왜 굳이 이렇게까지 해야 해?’ 싶을 수 있지만,<br>
컴포넌트가 많아지고, 팀원이 늘어나고, 유지보수를 하게 될수록 디자인 시스템의 필요성을 절실히 느낍니다.<br>
작은 프로젝트부터라도 토큰 하나, 버튼 하나부터 시작해보세요.<br>
다음 글에서는 실제로 디자인 토큰을 자동 변환하고, Storybook을 GitHub Pages에 배포하는 과정을 공유할게요!]]></description><link>1.개념-정리/프레임워크-&amp;-라이브러리/디자인-시스템(feat.-storybook).html</link><guid isPermaLink="false">1.개념 정리/프레임워크 &amp; 라이브러리/디자인 시스템(Feat. Storybook).md</guid><pubDate>Wed, 30 Apr 2025 16:03:14 GMT</pubDate></item><item><title><![CDATA[상태 관리]]></title><description><![CDATA[ 
 <br>
<br>Redux,Zustand<br>
Pure Redux<br>
플럭스 패턴 : action -&gt; dispatcher -&gt; store -&gt; view -&gt; action -&gt; dispatcher
<br>리덕스 : action -&gt; reducer -&gt; store -&gt; view<br>
스토어라는 하나의 객체에서 관리가 되어있고 리듀서를 거친다.<br>state는 전역상태로 관리할것만 저장해야한다.<br>
Redux,Zustand 모두 전역상태 조작 도구들이다.<br>
전역은 useState로 관리하면된다.<br>
리덕스는 플러스패턴 , 리코일은 아토믹 패션<br>Store를 구독하는 모든 컴포넌트가 리랜더링 되면 리덕스가 안좋은거 아닌가요?<br>
-&gt; 안정성이 있다. <br>npm install redux<br>
node index.js<br>const { createStore } = require('redux');

// 초기 state 를 정의
const initState = {
	name: '김코딩',
	post: []
}

// action 
// 객체. 액션 객체를 리턴하는 Action creator 함수를 작성
// 그 액션에 필요한 데이터를 넘기는 역할, 어떤 액션을 할 것인지 타입 지정
const changeUsername = (name) =&gt; {
	return {
		type: "CHANGE_NAME",
		name
	}
}

const addPost = (post) =&gt; {
	return {
		type: "ADD_POST",
		post
	}
}

// reducer
// 액션의 타입에 따라서 새로운 State를 생성해내는 순수 함수
const reducer = (prevState, action) =&gt; {
	switch (action.type) {
		case "CHANGE_NAME":
			return {
				...prevState,
				name: action.name
			}
		case "ADD_POST":
			return {
				...prevState,
				name: [...prevState.posts, action.post]
			}
		default:
			return prevState;
	}
}

// store
const store = createStore(reducer, initState) 


// dispatch
store.dispatch(changeUsername('steve'))
store.dispatch(addPost('post 1'))
store.dispatch(addPost('post 2'))

console.log(store.getState())
<br>프론트엔드 과제 전형 기출 문제 리스트<br>
퍼널 구조 / useFunnel<br>
디바운싱과 쓰로틀링 - 요청 받은것에 대해 최적화<br>
살펴보면 퀄리티 향상에 도움이 된다.<br><a rel="noopener nofollow" class="external-link" href="https://m.blog.naver.com/topblade71/222964598090" target="_blank">https://m.blog.naver.com/topblade71/222964598090</a><br>
<a rel="noopener nofollow" class="external-link" href="https://m.blog.naver.com/topblade71/222964598090" target="_blank">https://m.blog.naver.com/topblade71/222964598090</a>]]></description><link>1.개념-정리/프레임워크-&amp;-라이브러리/상태-관리-(redux,-zustand).html</link><guid isPermaLink="false">1.개념 정리/프레임워크 &amp; 라이브러리/상태 관리 (Redux, Zustand).md</guid><pubDate>Wed, 21 May 2025 09:01:48 GMT</pubDate></item><item><title><![CDATA[이넘, 클래스]]></title><description/></item><item><title><![CDATA[인터페이스]]></title><description><![CDATA[ 
 <br><br><br>타입스크립트에서 인터페이스는 객체 타입을 정의할 때 사용하는 문법이다.<br><br>interface User {
	name: string;
	age: number;
}

var seho: User = { name: '세호', age: 36 };
<br>인터페이스라는 예약어를 이용하여 User라는 인터페이스를 선언한 코드이다.<br>
인터페이스 속성으로 name과 age를 각각 문자열과 숫자 타입으로 정의했다.<br>
객체의 속성과 들어갈 데이터 타입을 정의하게 정의할 수 있다.<br><br>객체가 활용되는 모든 곳에 인터페이스를 쓸 수 있다.<br>
객체는 함수의 파라미터로도 사용되고 반환값으로도 사용될 수 있다.<br><br>interface Person {
	name: string;
	age: number;
}

function logAge(someone: Person) {
	console.log(somenone.age);
}

var captain = {name: 'Capt', age: 100};
logAge(captain); //100
<br>logAge()는 somenone이라는 인자를 받아 인자 안의 age 속성을 출력하는 간단한 함수이다.<br>
이 코드는 Person이라는 인터페이스를 선언한 후 logAge() 함수의 파라미터인 someone에 Person 타입을 정의한다.<br>
이름이 Capt이고 나이는 100인 객체를 captain이라는 변수에 할당하고 logAge() 함수에 넘긴 인자가 파라미터 타입을 만족하기 때문에 에러 없이 실행된다. <br><br>getPerson() 함수는 person 인터페이스 타입의 데이터를 받아 그대로 반환해 주고 있다.<br>
이 함수의 반환 타입을 명시적으로 표시하기 위해 다음과 같이 인터페이스로 함수의 반환 타입을 정의할 수 있다.<br>interface Person {
	name: string;
	age: number;
}

function getPerson(someone: Person) {
	return someone;
}

var hulk = getPerson({ name: 'hulk', age: 99 });
<br>getPerson() 함수의 호출 결과를 변수에 할당하면 다음과 같이 해당 변수가 Person 인터페이스 타입으로 추론된다.<br><br>interface Person {
	name?: string;
	age: number;
}
<br>속성을 2개 가진 객체에서 속성 1개만 필요할 때가 있다.<br>
이때 사용할 수 있는 것이 옵션 속성(optional property) 이다.<br><br>상속은 객체 간 관계 형성하는 방법이며, 상위 클래스의 내용을 하위 클래스가 물려받아 사용하거나 확장하는 기법을 의미한다.<br>
클래스를 상속받을 때 extends란 예약어를 사용했다. 인터페이스를 상속받을 때도 동일하게 extends 예약어를 사용한다. <br>interface Person {
	name: string;
	age: number;
}

interface Developer extends Person {
	skill: string;
}

var ironman: Developer = {
	name: '아이언맨',
	age: 21,
	skill: '만들기'
}
<br>Person 인터페이스를 선언하고 Developer 인터페이스에 extends로 상속한 것이다.<br>
이렇게 extends 키워드를 사용해서 인터페이스의 타입을 상속받아 확장하여 사용할 수 있고 여러번 상속을 받아서 정의할 수 있다. <br><br>var user = {
	name: '캡션',
	admin: true 
}
console.log(user['name']); //캡션

var companies = ['삼성', '네이버', '구글'];
console.log(companies[0]); //삼성
<br>user['name'] 형태로 객체의 특정 속성에 접근하거나 companies[0] 형태로 배열의 특정 요소에 접근하는 것을 인덱싱이라고한다. <br><br>interface StringArray {
	[index: number]: string;
}

var companies = ['삼성', '네이버', '구글'];
<br>StringArray 인터페이스의 속성의 [index: number] 가 어떤 숫자든 모두 속성의 이름이 될 수 있다는 의미이다.<br>
[index: number]: string; 에서 속성 이름은 숫자고 그 속성 값으로 문자열 타입이 와야한다는 의미이다.<br>
배열의 인덱스가 0이 될 수도 있고 99, 2000 등 어떤 숫자든 될 수 있기때문에 [index: number] 로 정의 한다.<br>companies[0]; //삼성
companies[2]; //구글
<br><br>interface SalaryMap {
	[level: string]: number;
}

var salary: SalaryMap = {
	junior: 100
};

var money = salary['junior'];
<br>이 SalaryMap 인터페이스는 속성 이름이 문자열 타입이고 속성 값이 숫자인 타입인 모든 속성 이름/속성 값 쌍을 허용하겠다는 의미이다. 객체의 속성에 접근하는 방법은 salary['junior'] 또는 salary.junior 모두 가능하다.<br>
다만 속성 이름에 숫자나 - 등 특수 기호가 들어가면 .junior 방식으로 접근할 수 없기 때문에 salary['junior'] 방식으로 접근해야한다.<br><br>이처럼 정확히 속성 이름을 명시하지 않고 속성 이름의 타입과 속성 값의 타입을 정의하는 문법을 인덱스 시그니처(index signature) 라고 한다. <br>interface SalaryMap {
	[level: string]: string;
}

var salary: SalaryInfo = {
	junior: '100원',
	mid: '400원',
	senior: '700원',
	ceo: '0원',
	newbie: '50원',
};
<br>단순히 객체와 배열을 인덱싱 할 때 활용될 뿐만 아니라 객체의 속성 타입을 유연하게 정의할 때도 사용된다.<br>
속성 이름이 문자열이고 속성 값의 타입이 문자열이기만 하면 1개든 100개든 모두 추가할 수 있는 장점이 생긴다.<br>interface User {
	[property: string]: string;
	id: string;
	name: string;
}

var seho: User = {
	id: '1',
	name: '세호',
	address: '판교'
};
<br>User라는 인터페이스에는 id와 name 속성이 무조건 들어간다고 한다면 섞어서 정의할 수도 있다.<br>
이처럼 객체의 속성 이른과 속성 값이 정해져 있는 경우에는 속성 이름과 속성 값 타입을 명시해서 정의하고, 속성 이름은 모르지만 속성 이름의 타입과 값의 타입을 아는 경우에는 인덱스 시그니처를 활용한다.]]></description><link>1.개념-정리/js-&amp;-ts/인터페이스.html</link><guid isPermaLink="false">1.개념 정리/JS &amp; TS/인터페이스.md</guid><pubDate>Fri, 09 May 2025 10:48:15 GMT</pubDate></item><item><title><![CDATA[타입 정의, 타입 별칭]]></title><description><![CDATA[ 
 <br><br><br><br>유니언 타입(union type)은 여러개의 타입 중 한개만 쓰고 싶을 때 사용하는 문법이다.<br>
자바스크립트의 OR 연산자의 |를 이용하여 여러개의 타입 중 1개를 사용하겠다고 선언하는 방식이 바로 유니언 타입니다.<br>function logText(text: string | number) {
	console.log(text);
}
logText('hi');
logText(100);
<br><br>유니언 타입은 다음과 같이 string과 number에서 모두 제공하는 toString()을 자동 완성할 수 있지만 any 타입은 자동 완성 되지 않는다.<br>function logText(text: string | number) {
	console.log(text.toString());  //hi
}

logText('hi');
<br><br>타입스크립트 입장에서는 함수에 인자를 넘겨 실행할 때 Person 타입이 올지 Developer 타입이 올지 알 수 없기 때문에 어느 타입이 오더라도 문제 없을 공통 속성인 name 속성만 자동 완성해준다.<br>
여기서 함수 내부에서 파라미터 타입의 종류에 따라 특정 로직을 실행하고 싶다면 다음과 같이 in 연산자를 사용해서 로직을 작성하면 된다. <br>interface Person {
	name: string;
	age: number;
}

interface Developer {
	name: string;
	skill: string;
}

function introduce(someone: Person | Developer) {
	if ('age' in someone) {
		console.log(someone.age);
		return;
	}
	if ('skill' in someone) {
		console.log(someone.skill);
		return;
	}
}

introduce({ name: 'captin', skill: 'lecture' });
<br><br><br>interface Person {
	name: string;
	age: number;
}

function logAge(someone: Person) {
	console.log(somenone.age);
}

var captain = {name: 'Capt', age: 100};
logAge(captain); //100
<br>logAge()는 somenone이라는 인자를 받아 인자 안의 age 속성을 출력하는 간단한 함수이다.<br>
이 코드는 Person이라는 인터페이스를 선언한 후 logAge() 함수의 파라미터인 someone에 Person 타입을 정의한다.<br>
이름이 Capt이고 나이는 100인 객체를 captain이라는 변수에 할당하고 logAge() 함수에 넘긴 인자가 파라미터 타입을 만족하기 때문에 에러 없이 실행된다. <br><br>getPerson() 함수는 person 인터페이스 타입의 데이터를 받아 그대로 반환해 주고 있다.<br>
이 함수의 반환 타입을 명시적으로 표시하기 위해 다음과 같이 인터페이스로 함수의 반환 타입을 정의할 수 있다.<br>interface Person {
	name: string;
	age: number;
}

function getPerson(someone: Person) {
	return someone;
}

var hulk = getPerson({ name: 'hulk', age: 99 });
<br>getPerson() 함수의 호출 결과를 변수에 할당하면 다음과 같이 해당 변수가 Person 인터페이스 타입으로 추론된다.<br><br>interface Person {
	name?: string;
	age: number;
}
<br>속성을 2개 가진 객체에서 속성 1개만 필요할 때가 있다.<br>
이때 사용할 수 있는 것이 옵션 속성(optional property) 이다.<br><br>상속은 객체 간 관계 형성하는 방법이며, 상위 클래스의 내용을 하위 클래스가 물려받아 사용하거나 확장하는 기법을 의미한다.<br>
클래스를 상속받을 때 extends란 예약어를 사용했다. 인터페이스를 상속받을 때도 동일하게 extends 예약어를 사용한다. <br>interface Person {
	name: string;
	age: number;
}

interface Developer extends Person {
	skill: string;
}

var ironman: Developer = {
	name: '아이언맨',
	age: 21,
	skill: '만들기'
}
<br>Person 인터페이스를 선언하고 Developer 인터페이스에 extends로 상속한 것이다.<br>
이렇게 extends 키워드를 사용해서 인터페이스의 타입을 상속받아 확장하여 사용할 수 있고 여러번 상속을 받아서 정의할 수 있다. ]]></description><link>1.개념-정리/js-&amp;-ts/타입-정의,-타입-별칭.html</link><guid isPermaLink="false">1.개념 정리/JS &amp; TS/타입 정의, 타입 별칭.md</guid><pubDate>Fri, 09 May 2025 10:16:53 GMT</pubDate></item><item><title><![CDATA[Node.js 기본 생태계]]></title><description><![CDATA[ 
 <br><br>Node.js는 백엔드 개발을 자바스크립트로 할 수 있게 해주는 런타임이며, 실제 개발에서는 패키지 매니저(NPM), 의존성 관리, 스크립트 실행 등 다양한 생태계 도구와 함께 사용된다.<br><br>
<br>Node.js는 브라우저가 아닌 환경에서 자바스크립트를 실행할 수 있게 해주는 런타임
<br>V8 JavaScript 엔진을 기반으로 하고 있으며, 비동기 I/O 처리에 강함
<br>주로 웹 서버, API 서버, CLI 도구 등으로 많이 사용됨
<br><br><br><br><br><br>
<br>Node.js 설치 시 함께 설치되는 기본 패키지 매니저
<br>외부 오픈소스 패키지를 설치/삭제/업데이트 가능
<br><br>npm init          # package.json 생성
npm install       # 의존성 설치
npm install &lt;pkg&gt; # 특정 패키지 설치
npm uninstall &lt;pkg&gt; # 패키지 제거
<br><br><br><br><br>npx는 Node.js 5.2 이상 버전부터 함께 제공되는 CLI 도구로,  패키지를 설치하지 않고도 한 번만 실행할 수 있도록 도와준다.<br><br><br><br>npx create-react-app my-app      # CRA 설치 없이 프로젝트 생성
npx eslint .                     # 로컬 ESLint 설치 없이 코드 검사
npx cowsay "Hello Node.js!"      # CLI 유틸 실행
<br><br><br>package.json은 Node.js 프로젝트의 메타 정보와 의존성, 실행 스크립트 등을 정의하는 설정 파일이다.<br>
프로젝트를 클론하거나 배포받았을 때, 이 파일만 있으면 npm install을 통해 동일한 환경 구축이 가능하다.<br><br><br><br>{
  "name": "my-app",
  "version": "1.0.0",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  },
  "main": "index.js",
  "license": "MIT"
}
<br><br>
<br>npm run dev처럼 scripts에 등록한 명령어를 단축 실행 가능
<br>dependencies는 운영 시 사용, devDependencies는 개발 환경에서만 사용
<br>실제 배포 시엔 --production 옵션으로 devDependencies 제외 가능
]]></description><link>1.개념-정리/node/기본-생태계.html</link><guid isPermaLink="false">1.개념 정리/Node/기본 생태계.md</guid><pubDate>Mon, 21 Apr 2025 09:56:42 GMT</pubDate></item></channel></rss>