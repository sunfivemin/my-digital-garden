<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.ico</url><title>blog</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 21 Feb 2025 07:44:11 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 21 Feb 2025 07:44:11 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[리눅스]]></title><description><![CDATA[ 
 <br><br>리눅스에서는 모든 것은 파일이라는 철학을 따른다. (마우스, 키보드와 같은 모드 디바이스 관련 기술도 파일과 같이 다룸)<br>
유닉스는 여러 프로그램이 서로 유기적으로 각자 일을 수행하면서 전체 시스템이 동작하도록 하는 철학을 따른다.<br>
<br>ubuntu 접속 명령어 : ssh -i seono.pem ubuntu@퍼블릭 IPv4 주소
<br><br>
<br>
whoami : 현재 로그인한 사용자 ID를 알려준다. ( root : 슈퍼관리자 ID )

<br>
sudo 명령어 : 사용자 ID지만 root 권한으로 실행 가능한 프로그램 ( eg. sudo apt-get update )

<br>
pwd : 현재 디렉토리 위치

<br>
ls : 파일에 대한 정보 (ls -al : 숨김 파일 포함)

<br>
chmod : 파일 권한 변경<br>
(eg. chmod 400 mysecurity.pem : 소유자가 읽기만 가능 /<br>
chmod -R 777 directory : 하위 디렉토리까지 모든 권한인 777 을 줄 때 -R을 붙여준다)

<br>
cat : 파일 보기

<br>
vi : 파일 만들기 (:wq 로 아무것도 쓰지 않고 저장하고 나온다.) 

<br>
rm : 강제 파일 삭제하기 (rm -rf 폴더명 : 폴더안에 있는 파일 모두 삭제)

<br><br>표준 입력 스트림 : stdin / 표준 출력 스트림 : stdout / 오류 출력 스트림 : stderr<br>
일반적으로 plain text로 콘솔에 출력된다.<br><br>표준 스트림 흐름을 바꿔줌, 출력 경로를 바꿈. &gt;, &lt; / 기존 파일에 추가는 &gt;&gt;, &lt;&lt;<br>
<br>ls &gt; files.txt : ls로 출력되는 표준 출력 스트림의 방향을 files.txt 로 덮어씀 (files.txt 에 ls 로 출력되는 결과가 저장)
<br>head &lt; files.txt : files.txt의 파일 내용이 head 라는 파일의 처음부터 10 라인까지 출력해주는 명령으로 넣어짐 (files.txt의 앞 10라인이 출력)
<br><br>출력 스트림을 다른 프로세스의 입력 스트림으로 연결한다.<br>
ls | grep files.txt : 특정 파일이 있는지 찾을 때 사용함.<br><br>foreground process : 쉘에서 해당 프로세스 실행을 명령한 후, 해당 프로세스 수행 종료까지 사용자가 다른 입력을 하지 못함.<br>
( 프로세스 실행 취소 - ctrl + c / 실행 중지하는 명령어 - ctrl + z )<br>background process : 사용자 입력과 상관없이 실행됨. (쉘에서 해당 프로세스 실행 시 맨 뒤에 &amp; 붙여줌)<br><br><br>옵션<br>
<br>-A : 모든 프로세스를 출력
<br>a (BSD) : 터미널과 연관된 프로세스를 출력, x 옵션과 같이 사용하여 모든 프로세스를 출력할 때 사용
<br>-a : 세션 리더를 제외하고 데몬 프로세스처럼 터미널에 종속되지 않은 모든 프로세스를 출력
<br>-e : 커널 프로세스를 제외한 모든 프로세스를 출력
<br>-f : 출력을 풀 포맷으로 표기 (유닉스 스타일), UID, PID, PPID 등이 함께 표시
<br>-l (System V), l (BSD) : 출력을 긴 포맷으로 표기, 프로세스의 정보를 길게 보여주는 옵션으로 우선순위와 관련된 PRI 값과 NI 값을 확인
<br>-o : 출력 포맷을 지정
<br>-M : 64비트 프로세스들을 출력
<br>-m : 프로세스뿐만 아니라 커널 스레드도 출력
<br>-p : 특정 PID를 지정하여 출력
<br>-r : 현재 실행 중인 프로세스 출력
<br>u (BSD) : 프로세스의 소유자를 기준으로 출력
<br>-u [사용자] : 특정 사용자의 프로세스 정보를 출력, 사용자를 지정하지 않는다면 현재 사용자 기준으로 출력
<br>x (BSD) : 데몬 프로세스처럼 터미널에 종속되지 않은 프로세스를 출력
<br>-x : 로그인 상태에 있는 동안 아직 완료되지 않은 프로세스를 출력. 유닉스 시스템은 사용자가 로그아웃한 뒤에도 임의의 프로세서가 계속 동작 가능 -&gt; 해당 프로세서는 자신이 실행시킨 쉘이 없어도 계속 자신의 일을 수행하는 데 이 프로세스는 해당 옵션 없이는 확인이 불가능
<br>출력 항목<br>
<br>USER (BSD), UID (System V) : 프로세스 소유자의 이름
<br>PID : 프로세스의 식별 번호
<br>PPID : 부모 프로세스의 PID
<br>%CPU : CPU 사용 비율의 추정치 (BSD)
<br>%MEM : Memory 사용 비율의 추정치(BSD)
<br>VSZ : K 단위 또는 페이지 단위의 가상 메모리 사용량
<br>RSS : 실제 메모리 사용량
<br>TTY : 프로세스와 연결된 터미널
<br>S (System V), STAT (BSD) : 현재 프로세스의 상태 코드
<br>TIME : 총 CPU 사용 시간
<br>COMMAND : 프로세스의 실행 명령 이름
<br>STIME : 프로세스가 시작된 시간 혹은 날짜
<br>C (System V), CP (BSD) : 짧은 기간 동안의 CPU 사용률
<br>F : 플래그
<br>PRI : 실제 실행 우선순위
<br>NI : nice 우선순위 번호
<br><br>프로세스 종료 시킴 / -9는 작업 강제 종료 옵션이다.<br>
<br>kill % 작업 번호(job number), kill 프로세스 ID(pid)
<br><br>cp 명령 : 파일 복사<br>
cp -rf * ../folder/ - 하부폴더 포함하여 현재폴더에 있는 모든 것들을 folder에 복사<br>하드링크 : ln A B<br>
A와 B는 동일한 데이터를 가리킴. A가 바뀌면 B도 바뀜.<br>소프트링크 : ln -s A B<br>
윈도우 OS의 바로가기와 같음. <br><br>리눅스 패키지 시스템의 다양한 배포판 중 하나<br>
최신 인덱스 정보 업데이트 : sudo apt-get update<br><br>
<br>Vim : Vi impreved 에서 앞글자만 딴 이름이다. Vi에 자동화, 시각화 메뉴를 추가한 프로그램
<br>Vi : 전통적인 유닉스 에디터 (Visual Editor)
<br>이맥스(Emacs)
<br><br>
<br>일반(명령) 모드 : 처음 실행하거나 입력/명령 모드에서 ESC 입력 시 - 찾기, 커서 이동 등
<br>명령(명령행) 모드 : 일반모드에서 : 입력 시 - 저장, 파일 읽기, vim 설정 등
<br>입력(편집) 모드 : 일반 모드에서 a, i, o 키 입력 시 - 내용 입력
<br>visual 모드 : 일반 모드에서 v 입력 시 - 블럭 복사/붙여넣기
<br><br>입력<br>
<br>i : 포커스 잡힌 커서 위치에서 편집 모드 시작
<br>a : 포커스 잡힌 커서 위치 바로 다음에서 편집모드 시작
<br>삭제(일반모드)<br>
<br>x : 커서의 한 문자 삭제
<br>파일 저장<br>
<br>:w 현재 오픈된 파일 저장
<br>:q 저장하지 않고 quit
<br>:wq 저장하고 종료
<br>:q! 강제 종료
<br><br>파일의 가장 첫 라인은 #!/bin/bash 로 시작하고 filename.sh와 같은 형태로 파일 이름을 작성함.<br>
(eg. chmod 764 hello.sh)<br>
echo 함수를 이용하여 화면에 쉘 명령어를 출력할 수 있음.<br>myinfo=("seon" 30 "it") 
echo ${myinfo[*]}
<br>와 같이 리스트 변수로 만들어 출력도 가능하다.<br><br>리눅스에서 여러 파일을 묶는 것을 archive(아카이브) 라고 한다. 확장자는 .tar<br>
<br>압축 시 : tar -cvzf [압축된 파일 이름] [압축할 파일이나 폴더명] 
<br>압축 해제 시 : tar -xvzf [압축 해제할 압축 아카이브 이름]
]]></description><link>cs/리눅스.html</link><guid isPermaLink="false">CS/리눅스.md</guid><pubDate>Fri, 21 Feb 2025 03:05:55 GMT</pubDate><enclosure url="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f49d.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f49d.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[프로토콜]]></title><description><![CDATA[ 
 <br><br>컴퓨터간 통신을 하기 위한 규칙 <br><br>ISO(국제표준화기구)에서 다양한 컴퓨터간 데이터 전송을 지원할 수 있는 추상 모델을 표준화<br>
<br>송신측 : 캡슐화(Encapsulation)
<br>수신측 : 역캡슐화(decapsulation)
<br>헤더(header) : 데이터 송신시, 필요한 정보를 데이터에 추가
<br>바디(body) : 실제 데이터
<br><br><br>
<br>TCP : 연결형 프로토콜, 데이터의 전송 순서 보장, 데이터 신뢰성 보장
<br>UDP : 비연결형 프로토콜, TCP보다 전송속도 빠름, 주로 스트리밍/브로드캐스팅 서비스 (UDP 데이터는 데이터그램)
<br><br>: 목적지의 어떤 응용 프로그램에 데이터를 전달해야하는지 식별하는 기능 / 포트 번호는 0~65535<br>
(일반적으로 웹서버는 80번, 이메일은 110번, FTP는 21번 포트를 씀)<br><br>OSI 7 Layer은 표준 모델이고 TCP/IP은 현실에서 인터넷 통신을 위해 사용하는 모델<br><br><br><br>: 8bit.8bit.8bit.8bit = 32bit로 구성 (2^32개 IP 주소) : 0.0.0.0 ~ 255.255.255.255<br><br>: 16bit.16bit.16bit.16bit.16bit.16bit.16bit.16bit = 128bit로 구성(2^128개의 IP 주소)<br>
<br>자기 PC의 IP 주소는 127.0.0.1 (DNS로는 localhost)
<br><br><br>
<br>Sequence Number : 일정 단위로 데이터를 분할해서 전송, 송신측에서 수식측 데이터가 몇번째인지 알려준다.
<br>ACK Number : 다음 번호의 데이터를 알려줌, 어디까지 수신했는지 확인 가능하다.
<br><br>
<br>3 way hand shake : TCP 통신을 위한 연결을 설정하는 과정
<br><br>
<br>4 way hand shake : TCP 연결을 해제 하는 과정
<br><br>네트워크 트래픽에 따른 효율적이고 신뢰적 송신을 위한 제어 알고리즘 적용<br><br>슬라이딩 윈도우 (Sliding Window, 매번 ACK를 기다리지 않고 여러 패킷을 연속해서 송신 / 각 컴퓨터의 윈도우 사이즈를 확인하여 윈도우 사이즈 만큼 ACK없이 연속해서 송신한다.)<br><br>송신 제어를 위한 2가지 윈도우가 있다. 송신측 최종 윈도우 크기는 min(RWND, CWND)<br>
<br>RWND(Receiver Window) : 슬라이딩 윈도우에서 활용 
<br>CWND(Congestion Window) : 네트워크 혼잡제어를 위해 활용
<br><br>: 처음에는 CWND = 1, ACK가 도착하면(패킷 전송 성공 시) -&gt; CWND = CWND + 1, 패킷 전송 실패 시 -&gt; CWND = CWND / 2<br>AIMD의 느린 초기 송신을 빠르게 하기 위해 느린시작과 혼잡회피가 있다.<br>
<br>느린시작(Slow Start) : 처음에는 CWND = 1, ACK가 도착하면(패킷 전송 성공 시) -&gt; CWND = CWND의 2배, 패킷 전송 실패 시 -&gt; CWND = 1(초기값)
<br>혼잡회피(Congestion Avoidance) : 느린시작과 같이 쓰이고 CWND가 일정 크기에 도달할 때, ACK가 도착하면(패킷 전송 성공 시) -&gt; CWND = CWND + 1
<br><br>사용자 데이터그램 프로토콜(User Datagram Protocol) : 동영상 스트리밍 등 데이터 유실이 일부 있어도 문제 없고 빠른 전송이 필요한 서비스에 활용된다. TCP와 달리 브로드캐스팅(동일 네트워크에 연결된 모든 컴퓨터에 데이터 송신 가능)을 지원한다.<br><br>HTTP(HyperText Transfer Protocol)<br>
: 인터넷(WWW, W3, Web) 상에서 서버와 클라이언트 모델로 정보를 주고 받는(request / response) 프로토콜<br><br>GET(서버 정보 읽기, 전달이 필요한 파라미터들을 URL을 통해 전달한다), POST(서버 정보 입력하기, 전달이 필요한 파라미터들을 HTTP BODY에 포함되어 잔달 되어 사용자는 직접 확인 불가하다), PUT(서버 정보 수정하기), DELETE(서버 정보 삭제하기)<br><br><br><br>세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리한다.<br><br>URL(Uniform Resource Locator) : 인터넷 상의 자원 위치 표기를 위한 규약<br>URI(Uniform Resource Identifier) : 통합 자원 식별자<br>
(eg. <a rel="noopener nofollow" class="external-link" href="https://search.naver.com" target="_blank">https://search.naver.com</a>/search.naver?where=nexearch&amp;sm=top_hty&amp;fbm=0&amp;ie=utf8&amp;query=url<br>
<a data-tooltip-position="top" aria-label="https://search.naver.com/%EC%9D%80" rel="noopener nofollow" class="external-link" href="https://search.naver.com/%EC%9D%80" target="_blank">https://search.naver.com/은</a> url 이고, search.naver?where=nexearch&amp;sm=top_hty&amp;fbm=0&amp;ie=utf8&amp;query=url 라는 식별자가 uri 이다.)<br>
<br>SSL 암호화 프로토콜은 넷스케이프사에서 개발되었고 국제 표준화 하는 괒어에서 SSL이 상용 제품 이름과 동일하여 TLS로 변경되었다.
<br><br>Rest(REpreseontational State Transfer) : HTTP URI를 통해 자원을 명시하고, HTTP 메서드를 통해 자원에 대한 CRUD Operation 적용한다.<br>
<br>Create : 생성(POST)
<br>Read : 조회(GET)
<br>Update : 수정(PUT)
<br>Delete : 삭제(DELETE)
<br>REST API : REST 기반으로 서비스 API 구현했다. 마이크로 서비스, Open API 등에서 많이 사용된다.<br>Restful : 개발자들 사이에서 비공식적으로 가이드한 REST 구현 가이드<br>
<br>기능에 적합한 URL Method 사용
<br>정의된 상태 코드에 맞게 상태 전송
<br>URL Rules(마지막에 / 포함하지 않는다, _대신 -를 사용한다, 소문자를 사용한다, 메서드는 URL에 포함하지 않는다 등)
<br><br>DNS(Domain Name System) : 전세계 흩어진 DNS Server를 통해 도메인 이름:IP 주소 정보를 확인할 수 있다. (UDP 사용)<br><br>
<br>웹 브라우저에 입력된 URL은 DNS 프로토콜을 사용하여 IP 주소로 변환(반대도 수행)
<br>HTTP Request -&gt; TCP -&gt; IP -&gt; Ethernet을 전기 신호로 변환 및 전송
<br><br>MIME(Multi-purpose Internet Mail Extensions)<br>
: SMTP 프로토콜은 ASCII 코드만 전송할 수 있다. SMTP 본문 내용에 MIME 헤더와 함께 다양한 포멧의 데이터를 ASCII 코드로 변환해서 전송한다. <br><br>서버와 클라이언트 사이의 파일 전달을 위한 프로토콜<br>
(21번 : 접속/제어를 위한 포트, 20번 : 전송을 위한 포트)]]></description><link>cs/프로토콜.html</link><guid isPermaLink="false">CS/프로토콜.md</guid><pubDate>Fri, 21 Feb 2025 02:56:46 GMT</pubDate><enclosure url="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f4af.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f4af.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CS]]></title><description><![CDATA[ 
 <br>
<br>하나
<br>둘
<br>셋
<br>넷
<br>
]]></description><link>cs/cs.html</link><guid isPermaLink="false">CS/CS.md</guid><pubDate>Fri, 21 Feb 2025 02:54:21 GMT</pubDate><enclosure url="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f649.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f649.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FRONTEND]]></title><description><![CDATA[ 
 <br><br>
<br>
Obsidian Vault 경로 확인

<br>현재 public 폴더 내에 custom-head.html이 있어야 합니다.
<br>사라졌다면 public 폴더 안에서 다시 생성해야 합니다.


<br>
파일 만들기

<br>public 폴더 안에서 새로운 파일을 생성하고 이름을 custom-head.html로 지정하세요.


<br>
내용 입력 (기본 예제)
html
복사편집
&lt;!DOCTYPE html&gt; &lt;html lang="ko"&gt; &lt;head&gt;     &lt;meta charset="UTF-8"&gt;     &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;     &lt;meta name="description" content="My Digital Garden"&gt;     &lt;title&gt;Custom Head&lt;/title&gt;      &lt;!-- FontAwesome CDN --&gt;     &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"&gt;      &lt;!-- 추가 CSS --&gt;     &lt;link rel="stylesheet" href="lib/styles/obsidian.css"&gt;     &lt;link rel="stylesheet" href="lib/styles/main-styles.css"&gt;     &lt;link rel="stylesheet" href="lib/styles/global-variable-styles.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;

<br>
파일 저장

<br>custom-head.html을 public/ 폴더 안에 배치하고 저장합니다.


<br>
Git 커밋 및 배포

<br>파일이 정상적으로 추가되었는지 확인 후 다음 명령을 실행합니다.

sh
복사편집
git add public/custom-head.html git commit -m "Add custom-head.html" git push origin main

<br><br><br>현재 obsidian.css가 한 줄로 표시되는 이유는 압축된(minified) 파일이기 때문입니다. 보기 쉽게 만들려면 포맷(Beautify) 해야 합니다.<br><br>
<br>obsidian.css 파일을 열고 전체 선택 (Cmd + A / Ctrl + A)
<br>Shift + Alt + F (VS Code에서 코드 자동 정렬)
<br><br>
<br>CSS Beautifier 같은 사이트에 접속합니다.
<br>obsidian.css의 내용을 복사하여 붙여넣기합니다.
<br>"Beautify" 버튼을 눌러 가독성을 높인 후, 다시 저장합니다.
<br><br>수정한 후 Git을 사용해 다시 배포합니다.<br>sh<br>복사편집<br>git add public/lib/styles/obsidian.css git commit -m "Fix obsidian.css formatting" git push origin main<br><br><br>현재 아이콘이 이상하게 보이는 이유는 FontAwesome이나 Obsidian 내장 아이콘이 적용되지 않았기 때문일 수 있습니다.<br><br>
<br>custom-head.html에 FontAwesome을 추가하면 해결될 가능성이 있습니다.
<br>이미 추가했다면 obsidian.css에서 clickable-icon 클래스를 확인하세요.
<br><br>
<br>obsidian.css에서 다음 스타일을 추가하세요.
  css
  복사편집
  .clickable-icon {     font-family: "Font Awesome 6 Free";     font-weight: 900;     display: inline-block;     width: 24px;     height: 24px;     text-align: center;     line-height: 24px; } .clickable-icon.sidebar-collapse-icon:before {     content: "\f104"; /* 왼쪽 화살표 */     font-family: "Font Awesome 6 Free"; } .clickable-icon.collapse-tree-button:before {     content: "\f107"; /* 아래쪽 화살표 */     font-family: "Font Awesome 6 Free"; }<br>

<br>이렇게 하면 사이드바 열고 닫기 아이콘과 트리 구조 접기 아이콘이 변경됩니다.
<br><br><br>Netlify에서 특정 파일이 사라지는 이유는 자동 빌드 시 특정 파일을 무시하거나 덮어쓰는 문제 때문일 가능성이 큽니다.<br><br>Netlify 배포 시 custom-head.html이 유지되도록 설정합니다.<br>
<br>
netlify.toml 파일을 열고 아래 내용을 추가하세요.
toml
복사편집
[[redirects]] from = "/" to = "/index.html" status = 200 force = true  [build] publish = "public" command = "cp custom-head.html public/custom-head.html &amp;&amp; cp -r notes public/notes"  [[headers]] for = "/*" [headers.values] Access-Control-Allow-Origin = "*"

<br>
git add . -&gt; git commit -m "Fix Netlify settings" -&gt; git push origin main 실행 후 Netlify에서 다시 배포하세요.

]]></description><link>frontend/frontend.html</link><guid isPermaLink="false">FRONTEND/FRONTEND.md</guid><pubDate>Fri, 21 Feb 2025 06:52:32 GMT</pubDate><enclosure url="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/2763.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/2763.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[서버와 유저가 통신하는 법 / RESTful API]]></title><description><![CDATA[ 
 <br><br>서버는 단순한 프로그램으로, 요청을 받아 처리하는 역할을 한다.<br>
예를 들어,  <br>
<br>사용자가 웹툰을 요청하면 웹툰 데이터를 전송  
<br>DB 데이터를 요청하면 해당 데이터를 반환  
<br>반대로 데이터를 저장해달라고 하면 저장  
<br>즉, 서버는 사용자의 요청을 정확한 방식으로 전달받아야 원하는 데이터를 반환할 수 있다.<br>
마음대로 요청하면 서버는 데이터를 주지 않는다.<br><br>서버에게 데이터를 요청하려면 두 가지 요소를 정확히 입력해야 한다.  <br>
<br>Method (어떤 작업을 수행할지)  
<br>URL (어떤 데이터를 요청할지)  
<br><br>
<br>GET → 데이터를 요청할 때  
<br>POST → 데이터를 서버에 전송할 때  
<br>PUT / UPDATE → 기존 데이터를 수정할 때  
<br>DELETE → 데이터를 삭제할 때  
<br>
📌 URL도 정확하게 작성해야 한다. 이를 엔드포인트(Endpoint) 라고 부른다.<br>
정확한 method와 URL을 사용해야 서버가 요청을 정상적으로 처리한다.
<br><br><br>REST(Representational State Transfer)는 좋은 API를 설계하는 원칙을 정의한 개념이다.<br>
RESTful API는 이 원칙을 따르는 API를 의미하며, 다음과 같은 특징을 가진다.<br><br>
<br>
Uniform Interface (일관성 있는 인터페이스)  

<br>하나의 URL은 하나의 데이터만 다뤄야 한다.  
<br>URL과 Method는 일관성 있고 예측 가능해야 한다.  


<br>
Client-Server 역할 분리  

<br>클라이언트(사용자)와 서버의 역할을 명확히 구분해야 한다.  
<br>서버의 DB를 직접 조작하지 않도록 설계해야 한다.  


<br>
Stateless (무상태성)  

<br>각 요청은 독립적이어야 하며, 이전 요청의 정보를 유지하지 않아야 한다.  
<br>즉, 서버는 클라이언트의 상태를 저장하지 않는다.  


<br>
Cacheable (캐싱 가능성)  

<br>서버의 응답 데이터는 캐싱이 가능해야 한다.  
<br>자주 요청되는 데이터는 브라우저나 CDN에서 캐싱할 수 있도록 설정해야 한다.  


<br>
Layered System (계층 구조)  

<br>API 서버는 보안, 로드밸런싱 등을 위해 여러 개의 계층을 가질 수 있다.  


<br>
Code on demand (선택적 실행 코드 지원)  

<br>필요할 경우 서버는 클라이언트에게 실행 가능한 코드를 제공할 수도 있다.  


<br>
🎯 REST 원칙을 완벽하게 따르는 서버는 거의 없으며, 권장사항으로 참고하는 개념이다.<br>
대부분은 Method와 URL을 명확하게 구성하는 것만으로도 RESTful API라고 부른다.
<br><br><br>RESTful API를 만들 때 URL을 보기 쉽게 설계하는 것이 중요하다.<br>✔ URL은 동사가 아니라 명사로 구성<br>
✔ 언더바 _ 대신 대시 - 사용<br>
✔ 파일 확장자 (.html 등) 제거<br>
✔ 하위 경로는 / 기호로 구분<br><br>
<br>✅ facebook.com/bbc/photos<br>
→ BBC 뉴스 계정의 사진첩  
<br>✅ instagram.com/explore/tags/food<br>
→ #food 태그가 포함된 게시물  
<br>위처럼 URL만 봐도 어떤 데이터가 반환될지 이해할 수 있도록 설계하는 것이 RESTful API의 핵심이다.<br><br>📌 정리하면...<br>
<br>서버에 요청하려면 Method + URL이 정확해야 한다.  
<br>REST는 API 설계의 권장 원칙이며, 완벽하게 지키지 않아도 된다.  
<br>URL은 직관적이고 명확하게 설계하는 것이 중요하다.
<br>🚀 RESTful API를 적용할 때 위 원칙들을 참고하자!  <br>]]></description><link>frontend/restful-api.html</link><guid isPermaLink="false">FRONTEND/RESTful API.md</guid><pubDate>Fri, 21 Feb 2025 06:50:31 GMT</pubDate><enclosure url="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f7e6.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/svg/1f7e6.svg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2025-02-21]]></title><description><![CDATA[<a class="tag" href="?query=tag:안녕안녕안녕" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#안녕안녕안녕</a> 
 <br><a href=".?query=tag:안녕안녕안녕" class="tag" target="_blank" rel="noopener nofollow">#안녕안녕안녕</a><br>
<br>오마이갓<br>
하하 
]]></description><link>2025-02-21.html</link><guid isPermaLink="false">2025-02-21.md</guid><pubDate>Fri, 21 Feb 2025 06:13:51 GMT</pubDate></item></channel></rss>