<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 401 at column 570: Invalid bytes in character encoding
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.ico</url><title>blog</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 24 Mar 2025 07:11:44 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 24 Mar 2025 07:11:43 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[디자인 시스템 (Design System)]]></title><description><![CDATA[<a class="tag" href="?query=tag:design-system" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#design-system</a> <a class="tag" href="?query=tag:frontend" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#frontend</a> <a class="tag" href="?query=tag:ui-development" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ui-development</a> 
 <br><br>블로그 목표<br>
<br>✔️ 체계적인 정리 - 디자인 시스템의 핵심 개념과 구성요소 정리
<br>✔️ 실무 중심 - 실제 프로젝트에 적용할 수 있는 구체적인 방법론 제시
<br>✔️ 최신 트렌드 - 현대적인 디자인 시스템 사례와 도구 소개
<br><br><br>
<br>제품의 디자인과 개발을 위한 표준화된 규칙과 원칙의 집합
<br>일관된 사용자 경험을 제공하기 위한 체계적인 가이드라인
<br>재사용 가능한 컴포넌트와 패턴의 라이브러리
<br><br>
<br>디자인 토큰 (색상, 타이포그래피, 간격 등)
<br>컴포넌트 라이브러리
<br>상호작용 패턴
<br>문서화 가이드
<br><br>// colors.js
export const colors = {
  primary: {
    main: '#007AFF',
    light: '#47A3FF',
    dark: '#0055B3'
  },
  grey: {
    100: '#F5F5F5',
    200: '#EEEEEE',
    300: '#E0E0E0'
  }
};

// spacing.js
export const spacing = {
  xs: '4px',
  sm: '8px',
  md: '16px',
  lg: '24px',
  xl: '32px'
};
<br><br>핵심 원칙<br>
<br>✔️ 재사용성 - 다양한 상황에서 활용 가능한 유연한 설계
<br>✔️ 일관성 - 디자인 토큰을 기반으로 한 통일된 스타일
<br>✔️ 접근성 - 모든 사용자를 고려한 포괄적인 설계
<br><br>// Button.tsx
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'ghost';
  size: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
  disabled?: boolean;
}

const Button = ({ variant, size, children, ...props }: ButtonProps) =&gt; {
  return (
    &lt;button 
      className={`btn btn-${variant} btn-${size}`}
      {...props}
    &gt;
      {children}
    &lt;/button&gt;
  );
};
<br><br><br>
<br>Atoms (기본 요소)

<br>버튼, 입력필드, 텍스트


<br>Molecules (복합 요소)

<br>검색창, 카드


<br>Organisms (섹션)

<br>네비게이션, 폼


<br>Templates (페이지 구조)
<br>Pages (최종 화면)
<br><br><br>기본적인 동작을 위한 버튼 컴포넌트입니다.<br><br>
  버튼 텍스트
<br><br><br><br><br>
<br>Figma
<br>Adobe XD
<br>Sketch
<br><br>
<br>Storybook
<br>Styled Components
<br>Emotion
<br><br>
<br><a data-href="컴포넌트 설계 패턴" href="컴포넌트 설계 패턴" class="internal-link" target="_self" rel="noopener nofollow">컴포넌트 설계 패턴</a>
<br><a data-href="디자인 시스템 사례 연구" href="디자인 시스템 사례 연구" class="internal-link" target="_self" rel="noopener nofollow">디자인 시스템 사례 연구</a>
<br><a data-href="Atomic Design 방법론" href="Atomic Design 방법론" class="internal-link" target="_self" rel="noopener nofollow">Atomic Design 방법론</a>
<br><a href=".?query=tag:design-system" class="tag" target="_blank" rel="noopener nofollow">#design-system</a> <a href=".?query=tag:frontend" class="tag" target="_blank" rel="noopener nofollow">#frontend</a> <a href=".?query=tag:ui-development" class="tag" target="_blank" rel="noopener nofollow">#ui-development</a>]]></description><link>📂-frontend/🎨-ui-&amp;-디자인/📝-디자인-시스템.html</link><guid isPermaLink="false">📂 FRONTEND/🎨 UI &amp; 디자인/📝 디자인 시스템.md</guid><pubDate>Sun, 23 Feb 2025 09:51:03 GMT</pubDate></item><item><title><![CDATA[문서 제목]]></title><description><![CDATA[ 
 ]]></description><link>📂-frontend/🏗️-아키텍처-&amp;-최적화/📝-테스트-자동화.html</link><guid isPermaLink="false">📂 FRONTEND/🏗️ 아키텍처 &amp; 최적화/📝 테스트 자동화.md</guid><pubDate>Sun, 23 Feb 2025 09:22:46 GMT</pubDate></item><item><title><![CDATA[문서 제목]]></title><description><![CDATA[ 
 ]]></description><link>📂-frontend/📦-프레임워크-&amp;-라이브러리/📝-next.js.html</link><guid isPermaLink="false">📂 FRONTEND/📦 프레임워크 &amp; 라이브러리/📝 Next.js.md</guid><pubDate>Sun, 23 Feb 2025 09:21:13 GMT</pubDate></item><item><title><![CDATA[문서 제목]]></title><description><![CDATA[ 
 ]]></description><link>📂-frontend/📦-프레임워크-&amp;-라이브러리/📝-상태-관리-(redux,-zustand).html</link><guid isPermaLink="false">📂 FRONTEND/📦 프레임워크 &amp; 라이브러리/📝 상태 관리 (Redux, Zustand).md</guid><pubDate>Sun, 23 Feb 2025 09:06:49 GMT</pubDate></item><item><title><![CDATA[문서 제목]]></title><description><![CDATA[ 
 ]]></description><link>📂-frontend/📦-프레임워크-&amp;-라이브러리/📝-vue.js.html</link><guid isPermaLink="false">📂 FRONTEND/📦 프레임워크 &amp; 라이브러리/📝 Vue.js.md</guid><pubDate>Sun, 23 Feb 2025 09:06:49 GMT</pubDate></item><item><title><![CDATA[문서 제목]]></title><description><![CDATA[ 
 ]]></description><link>📂-frontend/📦-프레임워크-&amp;-라이브러리/📝-seo-&amp;-ssr.html</link><guid isPermaLink="false">📂 FRONTEND/📦 프레임워크 &amp; 라이브러리/📝 SEO &amp; SSR.md</guid><pubDate>Sun, 23 Feb 2025 09:21:36 GMT</pubDate></item><item><title><![CDATA[문서 제목]]></title><description><![CDATA[ 
 ]]></description><link>📂-frontend/📦-프레임워크-&amp;-라이브러리/📝-react.html</link><guid isPermaLink="false">📂 FRONTEND/📦 프레임워크 &amp; 라이브러리/📝 React.md</guid><pubDate>Sun, 23 Feb 2025 09:40:35 GMT</pubDate></item><item><title><![CDATA[문서 제목]]></title><description><![CDATA[ 
 <br><br>블로그 목표
✔️ 체계적인 정리 - 빠르게 찾고 학습할 수 있도록 카테고리화<br>
✔️ 실무 중심 - 실제 프로젝트에서 마주치는 문제를 해결하는 방법 공유<br>
✔️ 최신 기술 반영 - 변화하는 웹 기술 트렌드를 따라가며 기록
<br>블로그 목표
✔️ 체계적인 정리 - 빠르게 찾고 학습할 수 있도록 카테고리화<br>
✔️ 실무 중심 - 실제 프로젝트에서 마주치는 문제를 해결하는 방법 공유<br>
✔️ 최신 기술 반영 - 변화하는 웹 기술 트렌드를 따라가며 기록
<br><br>
<br>useState
<br>useEffect
<br>useContext
<br><br>function Example() {
  const [count, setCount] = useState(0);
  // ...
}
]]></description><link>📂-frontend/🛠️-웹-기초/무제.html</link><guid isPermaLink="false">📂 FRONTEND/🛠️ 웹 기초/무제.md</guid><pubDate>Sun, 23 Feb 2025 09:43:21 GMT</pubDate></item><item><title><![CDATA[서버와 유저가 통신하는 법 / RESTful API]]></title><description><![CDATA[ 
 <br><br>서버는 단순한 프로그램으로, 요청을 받아 처리하는 역할을 한다.<br>
예를 들어,  <br>
<br>사용자가 웹툰을 요청하면 웹툰 데이터를 전송  
<br>DB 데이터를 요청하면 해당 데이터를 반환  
<br>반대로 데이터를 저장해달라고 하면 저장  
<br>즉, 서버는 사용자의 요청을 정확한 방식으로 전달받아야 원하는 데이터를 반환할 수 있다.<br>
마음대로 요청하면 서버는 데이터를 주지 않는다.<br><br>서버에게 데이터를 요청하려면 두 가지 요소를 정확히 입력해야 한다.  <br>
<br>Method (어떤 작업을 수행할지)  
<br>URL (어떤 데이터를 요청할지)  
<br><br>
<br>GET → 데이터를 요청할 때  
<br>POST → 데이터를 서버에 전송할 때  
<br>PUT / UPDATE → 기존 데이터를 수정할 때  
<br>DELETE → 데이터를 삭제할 때  
<br>
📌 URL도 정확하게 작성해야 한다. 이를 엔드포인트(Endpoint) 라고 부른다.<br>
정확한 method와 URL을 사용해야 서버가 요청을 정상적으로 처리한다.
<br><br><br>REST(Representational State Transfer)는 좋은 API를 설계하는 원칙을 정의한 개념이다.<br>
RESTful API는 이 원칙을 따르는 API를 의미하며, 다음과 같은 특징을 가진다.<br><br>
<br>
Uniform Interface (일관성 있는 인터페이스)  

<br>하나의 URL은 하나의 데이터만 다뤄야 한다.  
<br>URL과 Method는 일관성 있고 예측 가능해야 한다.  


<br>
Client-Server 역할 분리  

<br>클라이언트(사용자)와 서버의 역할을 명확히 구분해야 한다.  
<br>서버의 DB를 직접 조작하지 않도록 설계해야 한다.  


<br>
Stateless (무상태성)  

<br>각 요청은 독립적이어야 하며, 이전 요청의 정보를 유지하지 않아야 한다.  
<br>즉, 서버는 클라이언트의 상태를 저장하지 않는다.  


<br>
Cacheable (캐싱 가능성)  

<br>서버의 응답 데이터는 캐싱이 가능해야 한다.  
<br>자주 요청되는 데이터는 브라우저나 CDN에서 캐싱할 수 있도록 설정해야 한다.  


<br>
Layered System (계층 구조)  

<br>API 서버는 보안, 로드밸런싱 등을 위해 여러 개의 계층을 가질 수 있다.  


<br>
Code on demand (선택적 실행 코드 지원)  

<br>필요할 경우 서버는 클라이언트에게 실행 가능한 코드를 제공할 수도 있다.  


<br>
🎯 REST 원칙을 완벽하게 따르는 서버는 거의 없으며, 권장사항으로 참고하는 개념이다.<br>
대부분은 Method와 URL을 명확하게 구성하는 것만으로도 RESTful API라고 부른다.
<br><br><br>RESTful API를 만들 때 URL을 보기 쉽게 설계하는 것이 중요하다.<br>✔ URL은 동사가 아니라 명사로 구성<br>
✔ 언더바 _ 대신 대시 - 사용<br>
✔ 파일 확장자 (.html 등) 제거<br>
✔ 하위 경로는 / 기호로 구분<br><br>
<br>✅ facebook.com/bbc/photos<br>
→ BBC 뉴스 계정의 사진첩  
<br>✅ instagram.com/explore/tags/food<br>
→ #food 태그가 포함된 게시물  
<br>위처럼 URL만 봐도 어떤 데이터가 반환될지 이해할 수 있도록 설계하는 것이 RESTful API의 핵심이다.<br><br>📌 정리하면...<br>
<br>서버에 요청하려면 Method + URL이 정확해야 한다.  
<br>REST는 API 설계의 권장 원칙이며, 완벽하게 지키지 않아도 된다.  
<br>URL은 직관적이고 명확하게 설계하는 것이 중요하다.
<br>🚀 RESTful API를 적용할 때 위 원칙들을 참고하자!  <br>]]></description><link>📂-frontend/🛠️-웹-기초/restful-api.html</link><guid isPermaLink="false">📂 FRONTEND/🛠️ 웹 기초/RESTful API.md</guid><pubDate>Sun, 23 Feb 2025 07:37:55 GMT</pubDate></item><item><title><![CDATA[2025-03-24]]></title><description><![CDATA[ 
 <br>
<br>기술 스택 강화:

<br>JavaScript 심화 학습 (ES6+, 비동기 프로그래밍, Promise, async/await)
<br>최소 하나의 프레임워크/라이브러리 마스터 (React, Vue, Angular 중 하나 - 시장에서는 React가 가장 인기)
<br>상태 관리 도구 학습 (Redux, Context API, Vuex 등)
<br>TypeScript 학습 (많은 기업에서 필수로 요구)


<br>퍼블리셔 경험 활용:

<br>HTML/CSS 지식을 프론트엔드 개발에 접목
<br>UI/UX에 대한 이해를 장점으로 활용
<br>반응형 디자인 경험 강조


<br>포트폴리오 구축:

<br>실제 작동하는 프로젝트 2-3개 개발
<br>GitHub에 코드 공유 및 정리
<br>퍼블리싱과 프론트엔드 개발 기술이 모두 드러나는 프로젝트 진행


<br>추가 학습 영역:

<br>API 연동 (REST, GraphQL)
<br>테스트 작성 (Jest, React Testing Library)
<br>성능 최적화
<br>웹 접근성
<br>


<br>


<br><br><br>
<br>이미지 최적화

<br>적절한 포맷 사용 (WebP, AVIF 등)
<br>이미지 압축 및 적절한 크기 설정
<br>지연 로딩(Lazy Loading) 구현


<br>JavaScript 최적화

<br>코드 분할(Code Splitting)과 지연 로딩
<br>번들 크기 줄이기 (Tree Shaking)
<br>불필요한 렌더링 방지 (React의 경우 useMemo, useCallback 활용)


<br>CSS 최적화

<br>사용하지 않는 CSS 제거
<br>CSS 스플리팅
<br>Critical CSS 분리


<br>HTTP 요청 최적화

<br>HTTP/2 활용
<br>리소스 병합
<br>CDN 활용


<br><br>
<br>렌더 트리 최적화

<br>DOM 조작 최소화
<br>CSS 선택자 최적화
<br>애니메이션 최적화 (transform, opacity 활용)


<br>리페인트/리플로우 최소화

<br>배치 DOM 업데이트
<br>will-change 속성 사용
<br>requestAnimationFrame 활용


<br>메모리 관리

<br>메모리 누수 방지
<br>이벤트 리스너 정리
<br>대형 객체 참조 관리


<br><br>
<br>성능 측정 도구

<br>Lighthouse
<br>Chrome DevTools Performance 탭
<br>Web Vitals 모니터링


<br>주요 성능 지표

<br>FCP (First Contentful Paint)
<br>LCP (Largest Contentful Paint)
<br>CLS (Cumulative Layout Shift)
<br>TTI (Time to Interactive)


<br><br><br>
<br>인식의 용이성

<br>텍스트가 아닌 콘텐츠에 대안 텍스트 제공
<br>시간 기반 미디어에 자막과 오디오 설명 제공
<br>콘텐츠를 다양한 방식으로 표현
<br>사용자가 콘텐츠를 쉽게 보고 들을 수 있도록 구분


<br>운용의 용이성

<br>키보드로 모든 기능 사용 가능
<br>콘텐츠 읽기와 사용에 충분한 시간 제공
<br>발작 유발 요소 방지
<br>네비게이션과 위치 찾기 용이성


<br>이해의 용이성

<br>텍스트 읽기 쉽고 이해하기 쉽게
<br>콘텐츠 표시 및 작동 방식 예측 가능
<br>사용자 실수 방지 및 정정 도움


<br>견고성

<br>현재 및 미래 기술과의 호환성


<br><br>
<br>시맨틱 HTML 사용

<br>적절한 HTML5 요소 활용 (nav, article, section 등)
<br>헤딩 레벨 (h1-h6) 올바르게 구조화
<br>ARIA 속성 적절히 사용


<br>폼 접근성

<br>label 요소로 입력 필드 설명
<br>오류 메시지 명확하게 표시
<br>필수 입력 필드 표시
<br>포커스 상태 시각적으로 구분


<br>키보드 접근성

<br>모든 상호작용 요소 키보드로 접근 가능
<br>논리적인 탭 순서
<br>키보드 함정(trap) 방지
<br>단축키 제공 및 충돌 방지


<br>색상 및 대비

<br>색상만으로 정보 전달하지 않기
<br>충분한 색상 대비 (WCAG AA 기준 4.5:1)
<br>텍스트 크기 조절 가능


<br>스크린 리더 지원

<br>대체 텍스트 제공
<br>콘텐츠의 논리적 순서
<br>숨겨진 콘텐츠 적절히 처리
<br>실시간 변경사항 알림 (ARIA live regions)


<br><br>
<br>자동화 도구

<br>axe, WAVE, Lighthouse 등
<br>컬러 대비 검사기


<br>실제 사용자 테스트

<br>다양한 보조 기술 사용자 테스트
<br>키보드 전용 테스트
<br>다양한 기기 및 브라우저 테스트


<br>지속적인 모니터링

<br>접근성 회귀 테스트
<br>사용자 피드백 수집 및 반영


<br><br>
<br>서로 보완하는 관계

<br>시맨틱 HTML은 접근성과 SEO 모두에 도움
<br>최적화된 이미지는 로딩 속도를 향상시키고 대체 텍스트로 접근성 개선
<br>간결한 JavaScript는 성능과 스크린 리더 호환성 개선


<br>모바일 사용자 경험 향상

<br>빠른 로딩 시간은 모든 사용자에게 중요
<br>터치 타겟 크기 확대는 모터 장애가 있는 사용자와 일반 사용자 모두에게 유용


<br>비즈니스 가치

<br>더 넓은 사용자층 접근 가능
<br>법적 요구사항 충족
<br>검색 엔진 최적화 향상


<br>이 내용을 바탕으로 블로그를 작성하시면 프론트엔드 개발자로서의 전문성을 보여줄 수 있는 좋은 자료가 될 것입니다. 실제 코드 예제나 프로젝트에서의 경험을 추가하시면 더욱 풍부한 콘텐츠가 될 수 있습니다.]]></description><link>📂-study-notes/til-(today-i-learned)/2025-03-24.html</link><guid isPermaLink="false">📂 Study Notes/TIL (Today I Learned)/2025-03-24.md</guid><pubDate>Sun, 02 Mar 2025 13:29:21 GMT</pubDate></item><item><title><![CDATA[🏠 home]]></title><description/></item><item><title><![CDATA[TypeScript Type Alias, Interface, Class]]></title><description><![CDATA[ 
 <br><br><br>Type Alias는 기존 타입에 별칭(Alias) 을 부여하는 기능입니다.<br>
객체뿐만 아니라 유니온 타입, 함수 타입, 튜플 등 다양한 타입을 정의할 때 사용됩니다.<br><br>// 기본 타입에 별칭 부여
type UserId = number;
type UserName = string;
type IsActive = boolean;

let userId: UserId = 12345;
let userName: UserName = "홍길동";
let isActive: IsActive = true;
<br><br>// 주문 상태 타입 정의
type OrderStatus = "pending" | "processing" | "shipped" | "delivered" | "canceled";

type Order = {
  id: number;
  productId: number;
  customer: string;
  quantity: number;
  status: OrderStatus;
  orderDate: Date;
};

// 사용 예
const order1: Order = {
  id: 1001,
  productId: 5,
  customer: "이지은",
  quantity: 2,
  status: "pending",
  orderDate: new Date(),
};
<br>✅ 유니온 타입을 활용하면 제한된 값만 사용할 수 있어 안전한 코드 작성이 가능!<br><br>// 함수 타입 별칭
type Calculator = (a: number, b: number) =&gt; number;

const add: Calculator = (x, y) =&gt; x + y;
const multiply: Calculator = (x, y) =&gt; x * y;

console.log(add(10, 20));  // 30
console.log(multiply(10, 20));  // 200
<br><br><br>읽기 전용 속성을 사용하면 객체의 불변성(immutability) 을 유지할 수 있습니다.<br>type User = {
  readonly id: number;
  readonly createdAt: Date;
  name: string;
  age: number;
};

const user: User = {
  id: 12345,
  createdAt: new Date(),
  name: "홍길동",
  age: 30,
};

// 가능: 일반 속성 수정
user.name = "김철수";
user.age = 31;

// 에러: readonly 속성 수정 불가
// user.id = 67890;
// user.createdAt = new Date();
<br>✅ 읽기 전용 속성을 활용하면 데이터를 보호할 수 있음!<br><br><br>Interface는 객체의 구조를 정의하는 용도로 사용됩니다. type alias와 유사하지만, extends를 통해 다른 인터페이스를 확장할 수 있으며, 클래스에서도 implements 키워드로 사용할 수 있습니다.<br><br>interface Car {
  model: string;
  price: number;
  tax(): number;
}

const myCar: Car = {
  model: "Tesla",
  price: 5000,
  tax() {
    return this.price * 0.1;
  },
};
<br><br>interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

const myDog: Dog = {
  name: "바둑이",
  breed: "골든 리트리버",
};
<br>✅ **extends**를 사용하여 기존 인터페이스를 확장할 수 있음!<br><br><br><br><br><br>TypeScript에서 클래스(Class) 는 객체를 만들기 위한 설계도(템플릿) 입니다.<br>
코드를 재사용하고, 구조화하여 효율적인 프로그래밍이 가능합니다.<br><br>class Car {
  model: string;
  price: number;

  constructor(model: string, price: number) {
    this.model = model;
    this.price = price;
  }

  tax(): number {
    return this.price * 0.1;
  }
}
<br><br>class Animal {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
  sound() {
    console.log(`${this.name}이(가) 소리를 냅니다.`);
  }
}

class Dog extends Animal {
  bark() {
    console.log(`${this.name}이(가) 멍멍! 짖습니다.`);
  }
}
<br>✅ 부모 클래스의 기능을 유지하면서 새로운 기능 추가 가능!<br><br><br>✔ 객체 구조를 정의할 때 → interface 사용 (확장 가능)<br>
✔ 유니온 타입, 튜플, 함수 타입을 정의할 때 → type alias 사용<br>
✔ 클래스를 사용할 때, 인터페이스를 활용 → interface + implements 사용<br>
✔ 클래스에서 공통 속성을 물려받을 때 → extends 사용<br><br><br>이번 글에서는 TypeScript에서 자주 사용되는 type alias, interface, class의 개념과 차이점을 살펴보았습니다. 각각의 개념을 잘 활용하면 더 안전한 타입 기반 코드를 작성할 수 있습니다. 🎯]]></description><link>📂-frontend/⚡-js-&amp;-ts/📝-ts-기초.html</link><guid isPermaLink="false">📂 FRONTEND/⚡ JS &amp; TS/📝 TS 기초.md</guid><pubDate>Thu, 13 Mar 2025 02:05:37 GMT</pubDate></item></channel></rss>