<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 776 at column 425: Invalid bytes in character encoding
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.ico</url><title>blog</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 15 Jun 2025 11:38:31 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 15 Jun 2025 11:37:58 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[🎨 실무에서 통하는 디자인 시스템 설계와 Storybook 활용법]]></title><description><![CDATA[ 
 <br><br>React 프로젝트를 진행하다 보면 자연스럽게 드는 생각이 하나 있어요.<br>
“공통 UI 요소가 자꾸 반복되는데, 좀 더 체계적으로 정리할 수 없을까?”<br>
이때 필요한 게 바로 디자인 시스템입니다. 그리고 이를 문서화하고 테스트할 수 있는 최고의 도구는 바로 Storybook이죠.<br>이번 글에서는 디자인 시스템을 왜 쓰는지부터, 어떻게 구성하면 실무에 유리한지, 그리고 Storybook을 통해 어떻게 문서화하고 협업까지 연결할 수 있는지를 정리해봤어요.<br><br><br>디자인 시스템은 일관된 UI/UX를 제공하기 위한 설계 기준이에요.<br>
예를 들어 팀원들이 만든 버튼이 다 제각각이면 유지보수도 어렵고 사용자 경험도 들쑥날쑥하죠.<br>
이런 문제를 막기 위해 공통 컴포넌트, 스타일 가이드, 디자인 토큰 등을 하나로 정리한 시스템이 필요합니다.<br>
<br>버튼, 인풋, 카드 같은 공통 컴포넌트
<br>컬러, 폰트, 여백 같은 스타일 기준값 (디자인 토큰)
<br>사용법과 예제, 문서화
<br>이런 것들을 미리 정리해두면 개발도 빨라지고, 유지보수도 쉬워지고, 협업도 편해집니다.<br><br>
<br>디자이너와 협업 시 Figma 토큰을 기준으로 개발자가 변환해서 코드에 반영
<br>컴포넌트가 중복되지 않도록 공유된 디자인 토큰 기반으로 개발
<br>새로운 페이지가 생겨도 공통 컴포넌트 조합만으로 빠르게 개발 가능
<br>팀 규모가 커질수록 Storybook을 내부 개발자용 UI 가이드로 배포
<br><br><br>토큰과 컴포넌트를 분리해두면 규모가 커져도 정리가 잘 돼요.<br>src/
├── components/         # Button, Input, Card 등 공통 UI 컴포넌트
├── designSystem/
│   ├── tokens/         # 색상, 타이포, 여백 등 디자인 토큰
│   │   ├── colors.js
│   │   ├── spacing.js
│   │   └── typography.js
│   └── index.js        # 모든 토큰 모듈화
├── pages/              # 실제 페이지 단위 컴포넌트
└── App.jsx
<br><br><br>디자인 토큰은 스타일 기준값을 변수처럼 관리하는 것이에요.<br>
한 번만 정의해두면, 나중에 전체 테마 바꾸기도 편하고, 디자이너 피드백 반영도 훨씬 수월해요.<br>// designSystem/tokens/colors.js
export const colors = {
  primary: "#3B82F6", // Tailwind blue-500
  secondary: "#F3F4F6",
  danger: "#EF4444",
  text: "#1F2937",
};

// designSystem/tokens/typography.js
export const fontSize = {
  sm: "0.875rem",
  base: "1rem",
  xl: "1.25rem",
};

<br><br><br>variant, icon, disabled 같은 props도 추가해두면 더 유연한 컴포넌트가 됩니다.<br>// components/Button.jsx
import { colors } from "../designSystem/tokens/colors";

export default function Button({ label, onClick, variant = "primary" }) {
  const style = {
    backgroundColor: colors[variant],
    color: "#fff",
    padding: "8px 16px",
    borderRadius: "8px",
    fontSize: "0.875rem",
  };

  return &lt;button onClick={onClick} style={style}&gt;{label}&lt;/button&gt;;
}
<br><br><br>Storybook은 컴포넌트를 독립적으로 개발하고 테스트할 수 있도록 해주는 도구예요.<br>
디자이너, 기획자, QA가 개발 서버를 보지 않고도 UI 상태를 확인할 수 있게 해주죠.<br>
Docs 탭, Controls, Canvas를 통해 컴포넌트의 상태와 props를 바로 확인하고 테스트할 수 있어요.<br>Storybook에서는<br>
<br>컴포넌트 상태별 stories 작성 (Primary, Disabled, WithIcon 등)
<br>Docs 탭: 컴포넌트 사용 방법과 &nbsp;UI 상태 등을 문서처럼 자동 정리
<br>Controls 탭: props 값을 직접 조절해보면서 테스트 가능
<br>npx storybook init
npm run storybook
<br>// Button.stories.jsx
import Button from "./Button";

export default {
  title: "Components/Button",
  component: Button,
};

export const Primary = {
  args: {
    label: "확인",
    variant: "primary",
  },
};

<br><br><br>
<br>디자인 시스템이 있는 회사에서는 Figma 디자인 → 토큰으로 변환 → 컴포넌트에 적용
<br>Storybook을 통해 팀원들에게 공통 UI를 보여주고 가이드라인처럼 활용
<br>규모가 클수록, 팀원이 많을수록 디자인 시스템과 Storybook은 필수예요
<br>배포된 Storybook은 퍼블릭 문서처럼 외부에 공개할 수도 있고, 디자인 QA에도 유용해요.
<br><br><br><br>
<br>GitHub Pages / Vercel / Netlify에 정적 사이트로 배포 가능
<br>storybook-static 폴더를 GitHub Actions로 자동 배포
<br>디자이너나 팀원에게 배포된 링크로 컴포넌트 가이드를 제공
<br>.storybook 폴더 내 설정을 정리해 build-storybook 명령어로 HTML 생성
<br>npm run build-storybook
<br><br>
<br>Figma에서 디자인 토큰을 export → style-dictionary로 변환 → 코드 자동 생성 가능
<br>CSS 변수 → JS 모듈로 변환
<br>혹은 Tailwind의 theme.extend에 직접 바인딩
<br>테마를 여러 개로 나눠도 유지보수가 쉬워짐
<br>이렇게 하면 디자이너가 디자인을 바꾸면, 바로 코드에 반영되도록 자동화할 수 있어요.<br><br><br>처음엔 ‘왜 굳이 이렇게까지 해야 해?’ 싶을 수 있지만,<br>
컴포넌트가 많아지고, 팀원이 늘어나고, 유지보수를 하게 될수록 디자인 시스템의 필요성을 절실히 느낍니다.<br>
작은 프로젝트부터라도 토큰 하나, 버튼 하나부터 시작해보세요.<br>
다음 글에서는 실제로 디자인 토큰을 자동 변환하고, Storybook을 GitHub Pages에 배포하는 과정을 공유할게요!<br> 👉다음 글 : <a data-href="Express 기반 유튜버 API 프로젝트" href="2.dev-log/express-&amp;-node/express-기반-유튜버-api-프로젝트.html" class="internal-link" target="_self" rel="noopener nofollow">Express 기반 유튜버 API 프로젝트</a>]]></description><link>1.개념-정리/프레임워크-&amp;-라이브러리/디자인-시스템(feat.-storybook).html</link><guid isPermaLink="false">1.개념 정리/프레임워크 &amp; 라이브러리/디자인 시스템(Feat. Storybook).md</guid><pubDate>Sun, 15 Jun 2025 09:29:49 GMT</pubDate></item><item><title><![CDATA[상태 관리]]></title><description><![CDATA[ 
 <br>
<br>Redux,Zustand<br>
Pure Redux<br>
플럭스 패턴 : action -&gt; dispatcher -&gt; store -&gt; view -&gt; action -&gt; dispatcher
<br>리덕스 : action -&gt; reducer -&gt; store -&gt; view<br>
스토어라는 하나의 객체에서 관리가 되어있고 리듀서를 거친다.<br>state는 전역상태로 관리할것만 저장해야한다.<br>
Redux,Zustand 모두 전역상태 조작 도구들이다.<br>
전역은 useState로 관리하면된다.<br>
리덕스는 플러스패턴 , 리코일은 아토믹 패션<br>Store를 구독하는 모든 컴포넌트가 리랜더링 되면 리덕스가 안좋은거 아닌가요?<br>
-&gt; 안정성이 있다. <br>npm install redux<br>
node index.js<br>const { createStore } = require('redux');

// 초기 state 를 정의
const initState = {
	name: '김코딩',
	post: []
}

// action 
// 객체. 액션 객체를 리턴하는 Action creator 함수를 작성
// 그 액션에 필요한 데이터를 넘기는 역할, 어떤 액션을 할 것인지 타입 지정
const changeUsername = (name) =&gt; {
	return {
		type: "CHANGE_NAME",
		name
	}
}

const addPost = (post) =&gt; {
	return {
		type: "ADD_POST",
		post
	}
}

// reducer
// 액션의 타입에 따라서 새로운 State를 생성해내는 순수 함수
const reducer = (prevState, action) =&gt; {
	switch (action.type) {
		case "CHANGE_NAME":
			return {
				...prevState,
				name: action.name
			}
		case "ADD_POST":
			return {
				...prevState,
				name: [...prevState.posts, action.post]
			}
		default:
			return prevState;
	}
}

// store
const store = createStore(reducer, initState) 


// dispatch
store.dispatch(changeUsername('steve'))
store.dispatch(addPost('post 1'))
store.dispatch(addPost('post 2'))

console.log(store.getState())
<br>프론트엔드 과제 전형 기출 문제 리스트<br>
퍼널 구조 / useFunnel<br>
디바운싱과 쓰로틀링 - 요청 받은것에 대해 최적화<br>
살펴보면 퀄리티 향상에 도움이 된다.<br><a rel="noopener nofollow" class="external-link" href="https://m.blog.naver.com/topblade71/222964598090" target="_blank">https://m.blog.naver.com/topblade71/222964598090</a><br>
<a rel="noopener nofollow" class="external-link" href="https://m.blog.naver.com/topblade71/222964598090" target="_blank">https://m.blog.naver.com/topblade71/222964598090</a>]]></description><link>1.개념-정리/프레임워크-&amp;-라이브러리/상태-관리-(redux,-zustand).html</link><guid isPermaLink="false">1.개념 정리/프레임워크 &amp; 라이브러리/상태 관리 (Redux, Zustand).md</guid><pubDate>Wed, 21 May 2025 09:01:48 GMT</pubDate></item><item><title><![CDATA[폴더 구조]]></title><description><![CDATA[ 
 <br><br>/src
  /assets      # 이미지, 폰트 등
  /components  # UI 컴포넌트
  /constants   # 상수
  /hooks       # 커스텀 훅
  /models      # 유틸리티 함수
  /services    # API 호출
  /utils       # 유틸리티 함수
<br>이러한 구조는 처음 시작할 때 매우 자연스럽고 명확합니다. "이건 UI 컴포넌트니까 components에, 이건 API 통신이니까 services에" 하는 식으로 직관적으로 파일을 분류할 수 있습니다. 그래서 대부분의 튜토리얼이나 스타터 키트들도 이런 구조를 채택하고 있고 입문자에게도 아주 친숙합니다.<br>작은 프로젝트나 시작 단계에서는 이 구조가 특히나 효과적입니다. 파일 수가 적고, 각 폴더의 역할이 명확하며, 특정 종류의 코드를 찾기 쉽기 때문입니다.&nbsp;개발을 시작할 때 정신적 부담 없이 코드를 쉽게 나눌 수 있는 구조라고 할 수 있겠습니다.<br><br><br>/components
  /atoms            # 기본 요소
    Button.tsx
    Input.tsx
    Label.tsx
  /molecules        # 간단한 조합
    FormField.tsx
    SearchBar.tsx
  /organisms        # 복잡한 조합
    ProductCard.tsx
    NavigationBar.tsx
  /templates        # 페이지 템플릿
    ProductDetailTemplate.tsx
  /pages            # 전체 페이지
    ProductDetailPage.tsx
<br>실제 프로젝트의 폴더구조에 Atomic Design을 적용해보면 유용함과 한계점을 모두 마주하게 됩니다.&nbsp;분명 디자인 시스템을 직관적으로 보여주는데, 어디서 문제가 되는 걸까요? 한번 ProductCard 같은 컴포넌트를 생각해봅시다. ProductCard는 어디에 두어야 할까요? 내부적으로 Card와 Button을 사용하니 atom은 당연히 아닌 것 확실한데... 그래서 간단한 원자들로 조립했으니 molecules일까요? 아니면 비즈니스 로직을 포함하고 복잡하니 organisms?<br>
문제은 이 뿐만이 아닙니다. 이렇게 원자 - 분자 - 유기체 이렇게 3개의 폴더 구조만으로는 점점 더 많아지는 컴포넌트들을 감당하기가 어려워 집니다.<br>
왜 이런 문제가 생기는 걸까요? 그 이유는 Atomic Design Pattern이 간과한 중요한 점이 있었습니다.&nbsp;바로 모든 컴포넌트를 단순히 계층만으로 분류할 수 없다는 것이었죠.&nbsp;Atomic Design Pattern은 디자인 시스템에는 적합했지만, 실제 프로젝트의 컴포넌트들은 디자인 시스템에서 말하는 UI 컴포넌트로만 되어 있는 것이 아니었기 때문입니다.<br><br><br>프론트엔드 개발에는 근본적으로&nbsp;두 가지 다른 종류의 컴포넌트가 존재합니다. 디자인 시스템을 구성하는 순수한 UI 컴포넌트가 있다면, 그 컴포넌트들을 활용해서 비즈니스 로직을 구동하는 도메인 컴포넌트도 존재합니다.<br>
Atomic Design Pattern은 디자인 시스템의&nbsp;계층(atoms, molecules, organisms)을 표현하기에는 유용했지만, 또 다른 중요한 축인&nbsp;도메인(product, user, order)을 다루는 컴포넌트들을 제대로 분류하지 못한다는 한계가 있었습니다.<br>도메인이란 무엇일까요?&nbsp;도메인이란 비즈니스에서 다루는 개념적 영역을 말합니다. 쇼핑몰을 예로 들면 '제품', '장바구니', '사용자', '주문' 등이 주요 도메인이 됩니다. 그리고 제품목록, 주문내역, 사용자 다이얼로그 등이 바로 도메인정보를 다루는 컴포넌트, 즉 도메인 컴포넌트가 되겠습니다.<br>도메인 정보를 다루는 컴포넌트들은 기존의 버튼, 드롭다운, 모달 같은 순수한 화면 요소를 다루는 것에서 확장되면서 어떤 차이점을 가지고 있는지 한번 자세히 알아보겠습니다.<br>웹 개발 방식이 컴포넌트 기반 개발이 주류가 되면서,&nbsp;"컴포넌트는 재사용 가능해야 한다"는 원칙이 프론트엔드 개발의 핵심 철학으로 자리잡았습니다. 개발자들은 반복되는 버튼, 카드, 입력필드등에서의 중복 코드를 줄이고 일관된 UI를 구현하고 싶어했습니다. 그러면서도 컴포넌트를 최대한 독립적으로 만들려고 노력했고, 공통 코드는 모으되 props를 통해 외부에서 모든 것을 주입받도록 설계하는 것이 베스트 프랙티스로 여겨졌습니다.<br>function Button({ children, onClick, variant, size, disabled }) {
  return (
    &lt;button 
      className={`btn btn-${variant} btn-${size}`}
      onClick={onClick}
      disabled={disabled}
    &gt;
      {children}
    &lt;/button&gt;
  );
}
<br>Button 같은&nbsp;순수 UI 컴포넌트에서 이 접근법은 주효했습니다. 어디서든 사용할 수 있었고, 로그인 버튼이든, 장바구니 추가 버튼이든, 삭제 버튼이든 상관없이 일관된 동작을 보여주었습니다. 필요에 따라서 적절히 props를 통해서 공통 코드를 재사용하면서도 커스텀도 가능해지면서 컴포넌트를 "재사용성"이라는 원칙을 지키도록 작성하는 것은 중요한 덕목이 되었습니다.<br>이런 경험을 바탕으로 개발자들은 자연스럽게 다른 컴포넌트에도 같은 원칙을 적용하기 시작했습니다. 가령 상품 목록 리스트 항목을 그리는 ProductItem 같은 도메인 컴포넌트가 검색결과나 카탈로그, 찜 목록 등에 사용되니 다음과 같이 만들어 props를 통해 적절히 원하는대로 커스텀이 가능하도록 만들어 보았습니다.<br>function ProductItem({ product, onAddToCart, onToggleFavorite, showPrice, showRating }) {
  return (
    &lt;div className="product-item"&gt;
      &lt;img src={product.image} alt={product.name} /&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      {showPrice &amp;&amp; &lt;span&gt;{product.price}&lt;/span&gt;}
      {showRating &amp;&amp; &lt;Rating value={product.rating} /&gt;}
      &lt;Button onClick={() =&gt; onAddToCart(product)}&gt;장바구니&lt;/Button&gt;
      &lt;Button onClick={() =&gt; onToggleFavorite(product)}&gt;♡&lt;/Button&gt;
    &lt;/div&gt;
  );
}
<br>이러한 방식은 초기에는 잘 작동했습니다. 두 화면 모두에서 ProductItem을 재사용할 수 있었고, 옵션에 따라 원하는 필드의 노출이나 기능을 달리 할 수 있었죠. Button에서처럼 컴포넌트의 재사용이라는 목표를 달성하는 것 같았습니다.<br>하지만 프로젝트가 복잡해지면서 컴포넌트의 재사용성에 대한 의문이 생기기 시작했습니다. 가령 장바구니에서는 수량 조절이, 위시리스트에서는 다른 UI가 필요해지니 아래와 같이 재사용을 하기 시작했습니다.<br>// 처음엔 간단했는데...
&lt;ProductItem product={product} /&gt;

// 장바구니용 기능이 필요해지니...
&lt;ProductItem product={product} showQuantity={true} onQuantityChange={handleQuantity} /&gt;

// 위시리스트용도 추가하니...
&lt;ProductItem 
  product={product} 
  variant="wishlist" 
  showDate={true}
  showPriceAlert={true}
  onRemove={handleRemove}
/&gt;
<br>각각의 새로운 요구사항마다 props를 추가하는 것이 재사용이라는 측면에서는 당연한 조치였지만 예상과는 달리 코드는 점점 더 복잡해져갔습니다. props가 늘어날수록 컴포넌트를 사용하기가 더 어려워졌고, 내부 로직은 조건문으로 가득해졌습니다. 또한 새로운 기능을 추가할 때마다 다른 variant에서는 문제가 없는지 계속 확인해야 했죠.<br>나중에야 알게 된 사실이지만 이런 유형의 컴포넌트들은 전통적인 방식으로는 재사용리 잘 되지 않습니다.&nbsp;카탈로그의 ProductItem과 장바구니의 ProductItem은 겉보기에 같은 컴포넌트였지만 실제로는 다른 목적과 동작을 가지고 있었습니다. 그럼에도 하나의 컴포넌트로 억지로 묶어두다 보니 둘 다 최적화되지 못한 어정쩡한 결과물이 나온 것입니다.<br>구체적으로 잘못된 재사용을 하는 경우란&nbsp;데이터가 다른 데도 같은 UI를 사용한다는 이유로 하나의 컴포넌트로 추상화를 하는 방식입니다.<br>가령 게시판를 만든다고 생각해 봅시다. 공지사항, 문의게시판, 방명록 등이 프로젝트 전체에서 유사한 기능과 화면을 가지고 있으니 이를 하나의 컴포넌트로 만들어 API나 일부 화면만 분기하는 방식으로 재사용을 하려고 합니다.<br>그래서 다음과 같이 BoardList와 같은 컴포넌트를 만들고 API와 타입 등을 받아서 다른 데이터들을 일부 분기되는 처리와 옵션을 달리 하는 방식으로 만들어 보았습니다.<br>function BoardList({ 
  boardType, 
  apiEndpoint, 
  showAuthor = true, 
  showCategory = false,
  allowReply = false 
}) {
  const { data: posts } = useFetch(apiEndpoint);
  
  return (
    &lt;div className="board-list"&gt;
      {posts?.map(post =&gt; (
        &lt;div key={post.id} className="board-item"&gt;
          &lt;h3&gt;{post.title}&lt;/h3&gt;
          {showAuthor &amp;&amp; &lt;span&gt;작성자: {post.author}&lt;/span&gt;}
          {showCategory &amp;&amp; &lt;span&gt;분류: {post.category}&lt;/span&gt;}
          &lt;span&gt;{post.createdAt}&lt;/span&gt;
          {allowReply &amp;&amp; &lt;ReplyButton postId={post.id} /&gt;}
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// 사용 예시
&lt;BoardList boardType="notice" apiEndpoint="/api/notices" showCategory={true} /&gt;
&lt;BoardList boardType="qna" apiEndpoint="/api/qna" allowReply={true} /&gt;
&lt;BoardList boardType="guestbook" apiEndpoint="/api/guestbook" showAuthor={false} /&gt;
<br>이러한 방식은 얼핏 괜찮은 방식처럼 보입니다. 실제로 더 이상 프로젝트가 변하지 않거나 이 요구사항으로만 모든 기획을 처리해야할때 까지는 맞는 이야기입니다. 이 하나의 컴포넌트로 여러 종류의 게시판을 처리할 수 있었고, 코드 중복도 줄일 수 있었죠. 하지만 문제는 서비스가 잘되면 프로젝트와 요구사항은 언제나 변하고 커진다는 데에 있습니다.<br>요구사항은 화면이 아니라 도메인에 따라 방향성이 달라집니다.&nbsp;공지사항은 '중요' 배지 기능을 요구했고, 문의 게시판은 답변 상태나 비밀글 기능이 필요했으며, 방명록은 본문 미리보기도 같이 보여달라는 등 처음에는 같은 화면이었지만 점점 요구사항이 특수성에 따라 달라지는 것이고 이는 도메인의 특성에 기인하는 것이죠.<br>만일 현명하게 이를 대처하고자 했다면 BoardList는 데이터와 무관하게 화면과 기능을 확장할 수 있도록 하고 props가 아니라 다양한 컴포넌트를 조립할 수 있도록 만들어야 합니다. 그리고 각자 도메인별로는 코드의 중복을 인정하고 BoardList를 활용해서 각자의 방식으로 독립적으로 발전 할 수 있는 구조로 만들어야 하죠.<br><br>순수 UI 컴포넌트:<br>
<br>Button, Input, Modal, Dropdown 등
<br>도메인 지식이 전혀 필요 없음
<br>어떤 맥락에서든 동일하게 동작
<br>높은 재사용성이 가능하고 재사용성을 갖추는게 바람직한 방향
<br>디자인 시스템의 변화를 따라감
<br>도메인 컴포넌트:<br>
<br>ProductItem, UserProfile, OrderSummary 등
<br>특정 비즈니스 도메인의 개념을 표현
<br>맥락에 따라 다른 UI와 동작이 필요
<br>컴포넌트의 재사용이 중요한 가치가 아님
<br>비즈니스 요구사항의 변화를 따라감
<br>우리가 얻은 교훈은&nbsp;요구사항은 도메인을 중심으로 발전한다는 것이었습니다. 그렇기에 같은 화면을 가진 컴포넌트라도 코드가 중복되더라도 도메인에 따라 분리하는 것이 장기적으로 더 유지보수하기 좋은 방향이 되는만큼,&nbsp;도메인을 다루는 컴포넌트와 UI를 다루는 컴포넌트는 서로 다른 관점에서 접근하고 이를 분리해서 관리하는 방향으로 진화하게 되었습니다.<br><br>문제의 핵심은 도메인 컴포넌트에 비즈니스 로직이 섞여 있다는 점이었습니다. 이를 해결하기 위해&nbsp;컨테이너-프레젠터 패턴이 등장했습니다.<br>
이 패턴의 핵심은&nbsp;로직을 담당하는 컨테이너 컴포넌트와&nbsp;UI만 담당하는 프레젠터 컴포넌트를 분리하는 것이었습니다.<br>// 프레젠터: 순수하게 UI만 담당
function ProductItemView({ 
  product, 
  isInCart, 
  isFavorite, 
  onAddToCart, 
  onToggleFavorite 
}) {
  return (
    &lt;div className="product-item"&gt;
      &lt;img src={product.image} alt={product.name} /&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;span&gt;{product.price}&lt;/span&gt;
      &lt;Button 
        onClick={onAddToCart}
        disabled={isInCart}
      &gt;
        {isInCart ? '이미 담김' : '장바구니'}
      &lt;/Button&gt;
      &lt;Button 
        onClick={onToggleFavorite}
        variant={isFavorite ? 'filled' : 'outline'}
      &gt;
        ♡
      &lt;/Button&gt;
    &lt;/div&gt;
  );
}

// 컨테이너: 로직을 담당
function CatalogProductItem({ product }) {
  const { addToCart, isInCart } = useCart();
  const { toggleFavorite, isFavorite } = useFavorites();
  
  const handleAddToCart = () =&gt; {
    addToCart(product);
    // 카탈로그 특화 로직: 추천 시스템에 데이터 전송
    analytics.track('product_added_from_catalog', { productId: product.id });
  };
  
  const handleToggleFavorite = () =&gt; {
    toggleFavorite(product);
    // 카탈로그 특화 로직
    analytics.track('product_favorited_from_catalog', { productId: product.id });
  };
  
  return (
    &lt;ProductItemView
      product={product}
      isInCart={isInCart(product.id)}
      isFavorite={isFavorite(product.id)}
      onAddToCart={handleAddToCart}
      onToggleFavorite={handleToggleFavorite}
    /&gt;
  );
}

// 장바구니용 컨테이너는 완전히 다른 로직
function CartProductItem({ item }) {
  const { updateQuantity, removeItem } = useCart();
  
  const handleQuantityChange = (newQuantity) =&gt; {
    updateQuantity(item.id, newQuantity);
    analytics.track('cart_quantity_updated', { 
      productId: item.product.id, 
      quantity: newQuantity 
    });
  };
  
  // 장바구니에는 ProductItemView가 아닌 완전히 다른 UI 사용
  return (
    &lt;div className="cart-item"&gt;
      &lt;img src={item.product.image} alt={item.product.name} /&gt;
      &lt;div className="item-details"&gt;
        &lt;h4&gt;{item.product.name}&lt;/h4&gt;
        &lt;span&gt;{item.product.price} × {item.quantity}&lt;/span&gt;
      &lt;/div&gt;
      &lt;QuantitySelector 
        value={item.quantity}
        onChange={handleQuantityChange}
      /&gt;
      &lt;Button onClick={() =&gt; removeItem(item.id)}&gt;삭제&lt;/Button&gt;
    &lt;/div&gt;
  );
}
<br>이런 접근법은 각 컨테이너가 자신의 맥락에 최적화된 로직을 가질 수 있게 해주었습니다. 카탈로그에서는 "구매 유도"에, 장바구니에서는 "수량 관리"에 집중할 수 있었죠.<br><br>하지만 컨테이너-프레젠터 패턴으로도 해결되지 않는 문제가 있었습니다. 바로&nbsp;Props Drilling이었습니다. 독립성을 위해 필요한 데이터와 함수들을 계속 props로 전달해야 했고, 중간 계층 컴포넌트들은 실제로는 데이터 전달만 하면서도 모든 props를 받아서 다시 전달해야 했습니다.<br>function ProductSection({ products, onAddToCart, onToggleFavorite }) {
  return (
    &lt;ProductList 
      products={products} 
      onAddToCart={onAddToCart}
      onToggleFavorite={onToggleFavorite}
    /&gt;
  );
}

function ProductList({ products, onAddToCart, onToggleFavorite }) {
  return (
    &lt;div&gt;
      {products.map(product =&gt; (
        &lt;ProductItem 
          key={product.id}
          product={product} 
          onAddToCart={onAddToCart}
          onToggleFavorite={onToggleFavorite}
        /&gt;
      ))}
    &lt;/div&gt;
  );
}
<br>중간 계층의 컴포넌트들은 실제로는 데이터를 전달하는 역할만 하면서도, 독립성을 위해 모든 props를 받아서 다시 전달해야 했습니다. 재사용은 되지 않으면서 복잡도만 증가하는 상황이 벌어진 것입니다. 이는 UI 컴포넌트를 만들때에는 발생하지 않던 개념이었습니다.<br><br>이런 문제들을 해결하기 위해 프론트엔드 커뮤니티에서는 여러 패턴들이 자연스럽게 발전했습니다.&nbsp;Container-Presenter 패턴은 로직과 UI를 명확히 분리하려는 시도였고,&nbsp;커스텀 훅의 부상은 비즈니스 로직을 컴포넌트에서 분리하여 재사용 가능한 형태로 만드는 패턴이었습니다.&nbsp;Context API와 전역 상태 관리는 Props drilling 문제를 해결하고 도메인 상태를 효율적으로 관리하기 위한 패턴들이었습니다.<br>// 전역 상태를 활용한 도메인 컴포넌트
function CatalogProductItem({ product }) {
  // props drilling 없이 직접 필요한 로직에 접근
  const { addToCart, isInCart } = useCart();
  const { toggleFavorite, isFavorite } = useFavorites();
  
  return (
    &lt;div className="product-item"&gt;
      &lt;img src={product.image} alt={product.name} /&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;span&gt;{product.price}&lt;/span&gt;
      &lt;Button onClick={() =&gt; addToCart(product)}&gt;
        {isInCart(product.id) ? '이미 담김' : '장바구니'}
      &lt;/Button&gt;
      &lt;Button onClick={() =&gt; toggleFavorite(product.id)}&gt;
        {isFavorite(product.id) ? '❤️' : '♡'}
      &lt;/Button&gt;
    &lt;/div&gt;
  );
}
<br>이런 패턴들이 등장한 배경에는 공통된 인식이 있었습니다.&nbsp;도메인 컴포넌트는 props drilling 없이 필요한 도메인 로직에 직접 접근할 수 있어야 한다는 것이었습니다. 이는 기존의 "모든 것을 props로"라는 패러다임에서 "필요한 것을 직접 가져오기"라는 패러다임으로의 전환을 의미했습니다.<br><br><br>컴포넌트를 통해 발견한 "순수 UI"와 "도메인"의 구분은 사실 컴포넌트만의 이야기가 아니었습니다. 프로젝트가 성장하면서 이런 구분이 프론트엔드 개발의 모든 영역에서 나타나기 시작했죠.<br>훅(Hooks)에서도 마찬가지였습니다.&nbsp;useToggle(),&nbsp;useDebounce(),&nbsp;useClickOutside()&nbsp;같은 훅들은 어떤 도메인 지식도 필요 없는 순수한 유틸리티 훅이었습니다. 반면&nbsp;useCart(),&nbsp;useAuth(),&nbsp;useProductSearch()&nbsp;같은 훅들은 특정 비즈니스 로직과 밀접하게 연관되어 있었죠.<br>// 순수 유틸리티 훅 - 어디서든 사용 가능
function useDebounce(value: string, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() =&gt; {
    const handler = setTimeout(() =&gt; setDebouncedValue(value), delay);
    return () =&gt; clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}

// 도메인 훅 - 장바구니 비즈니스 로직 포함
function useCart() {
  const dispatch = useDispatch();
  const items = useSelector(selectCartItems);
  
  const addToCart = (product: Product) =&gt; {
    dispatch(cartActions.add(product));
    analytics.track('cart.item_added', { productId: product.id });
  };
  
  return { items, addToCart, totalPrice: calculateTotal(items) };
}
<br>API 레이어에서도 동일한 패턴이 보였습니다.&nbsp;httpClient.get(),&nbsp;httpClient.post()&nbsp;같은 기본 HTTP 통신 유틸리티와&nbsp;productApi.getAll(),&nbsp;cartApi.checkout()&nbsp;같은 도메인 특화 API는 성격이 완전히 달랐습니다. 전자는 어떤 프로젝트에서도 그대로 사용할 수 있지만, 후자는 해당 도메인의 비즈니스 규칙을 반영하고 있었죠.<br>심지어 유틸리티 함수들도 마찬가지였습니다.&nbsp;formatDate(),&nbsp;debounce(),&nbsp;deepClone()&nbsp;같은 범용 유틸리티와&nbsp;calculateShippingFee(),&nbsp;validateProductCode(),&nbsp;formatProductPrice()&nbsp;같은 도메인 유틸리티는 근본적으로 다른 성격을 가지고 있었습니다.<br><br>이런 발견은 자연스럽게 폴더 구조에도 반영되기 시작했습니다. 처음에는 단순히&nbsp;/components,&nbsp;/hooks,&nbsp;/services,&nbsp;/utils로 나누었지만, 각 폴더 내부에서는 도메인을 기준으로 세분화가 일어났죠.<br>/hooks
  /ui              # 순수 UI 관련 훅
    useModal.ts
    useDebounce.ts
    useToggle.ts
  /product         # 제품 도메인 훅
    useProducts.ts
    useProductDetail.ts
  /cart            # 장바구니 도메인 훅
    useCart.ts
    useCheckout.ts

/services
  /common          # 기본 API 클라이언트
    client.ts
    interceptors.ts
  /product         # 제품 도메인 API
    productApi.ts
  /cart            # 장바구니 도메인 API
    cartApi.ts
<br><br>컴포넌트는 도메인 중심의 세분화가 정착되면서 폴더 구조는 한층 체계적이 되었습니다. 하지만 여전히 해결되지 않은 불편함이 하나 있었죠. 바로 페이지 컴포넌트의 애매한 위치였습니다.<br>React로 처음 프로젝트를 시작했던 시절에는 모든 컴포넌트를 단순히&nbsp;/components&nbsp;폴더 안에 넣었습니다. HomePage, ProductListPage 같은 페이지 컴포넌트도, Button이나 Modal 같은 일반 컴포넌트도 모두 한 곳에 있었죠. 이름에 'Page'를 붙여서 구분하려 했지만, 프로젝트가 커질수록 이런 네이밍 컨벤션만으로는 부족했습니다.<br>/components
  Button.tsx
  Modal.tsx
  Header.tsx
  HomePage.tsx           # 페이지? 컴포넌트?
  LoginPage.tsx          
  ProductCard.tsx
  ProductListPage.tsx    # 이름으로만 구분
  ProductDetailPage.tsx
  CartIcon.tsx
  CartPage.tsx
  UserProfile.tsx
  UserSettingsPage.tsx
<br>더 큰 문제는 라우팅 설정과 실제 컴포넌트 사이의 거리였습니다. React Router 설정은 보통 App.js나 별도의 routes.js 파일에 있었고, 실제 페이지 컴포넌트는 components 폴더 깊숙한 곳에 있었죠. 새로운 개발자가 "이 URL은 어떤 컴포넌트를 렌더링하지?"라는 질문을 받으면, 라우팅 설정 파일을 열어보고, 거기서 import 경로를 따라가서, 해당 컴포넌트를 찾아야 했습니다. 단순해 보이지만 은근히 번거로운 과정이었죠.<br>페이지 컴포넌트는 분명 다른 컴포넌트들과는 다른 역할을 했습니다. URL과 직접 연결되고, 데이터 페칭의 시작점이 되며, SEO와 관련된 메타데이터를 설정하는 곳이었죠. 하지만 폴더 구조상으로는 이런 특별함이 전혀 드러나지 않았습니다. Button 컴포넌트 옆에 HomePage 컴포넌트가 나란히 있는 것은 뭔가 어색했습니다.<br><br>이런 불편함을 해소한 것이 바로 파일 기반 라우팅이었습니다. 파일 시스템의 구조가 곧 URL 구조가 된다는 간단한 아이디어였지만, 그 영향력은 대단했습니다. 이제&nbsp;/pages/products/[id].tsx&nbsp;파일을 만들면 자동으로&nbsp;/products/:id&nbsp;라우트가 생성되었습니다.<br>이와 같은 방법은 라우팅 설정을 별도로 관리할 필요가 없었고, URL만 보면 어떤 파일을 찾아가야 하는지 즉시 알 수 있었죠. 이는 단순히 편의성의 문제가 아니었습니다. 페이지라는 개념이 다른 컴포넌트들과는 본질적으로 다른 역할을 한다는 것을 구조적으로 개념화 한것이죠.<br>페이지는 애플리케이션의 진입점입니다. 사용자가 URL을 통해 직접 접근하는 곳이고, SEO가 중요한 곳이며, 데이터 페칭이 시작되는 곳이죠. 이런 특별한 역할을 하는 컴포넌트들을 일반 컴포넌트와 같은 폴더에 두는 것은 그 중요성을 제대로 반영하지 못한 것이었습니다<br><br><br>이렇게 역할별 분류, 도메인별 세분화, 그리고 페이지의 독립이라는 세 가지 진화가 만나면서 현대 프론트엔드 프로젝트의 일반적인 구조가 형성되었습니다. 대부분의 스타터 키트나 보일러플레이트를 열어보면 비슷한 패턴을 발견할 수 있죠.<br>/src
  /pages (또는 /app)     # 라우팅 진입점
    index.tsx
    about.tsx
    /products
      index.tsx
      [id].tsx
    /cart
      index.tsx
      checkout.tsx
    /auth
      login.tsx
      register.tsx
      
  /components           # UI 컴포넌트
    /ui                 # 순수 UI (도메인 무관)
      Button.tsx
      Modal.tsx
      Card.tsx
      Input.tsx
    /product           # 제품 도메인
      ProductCard.tsx
      ProductList.tsx
    /cart              # 장바구니 도메인
      CartItem.tsx
      CartSummary.tsx
    /layout            # 레이아웃 컴포넌트
      Header.tsx
      Footer.tsx
      Sidebar.tsx
      
  /hooks               # 커스텀 훅
    /ui                
      useModal.ts
      useDebounce.ts
    /product          
      useProducts.ts
      useProductDetail.ts
    /cart             
      useCart.ts
    /auth
      useAuth.ts
      usePermissions.ts
      
  /services           # API 레이어
    /api              
      client.ts
      interceptors.ts
    /product          
      productApi.ts
    /cart             
      cartApi.ts
    /auth
      authApi.ts
      
  /store              # 상태 관리
    /slices
      productSlice.ts
      cartSlice.ts
      authSlice.ts
    store.ts
    
  /utils              # 유틸리티
    /common
      formatters.ts
      validators.ts
      constants.ts
    /product
      priceCalculator.ts
    /date
      dateHelpers.ts
      
  /types              # TypeScript 타입 정의
    /models
      product.ts
      user.ts
      cart.ts
    /api
      responses.ts
      requests.ts
      
  /styles             # 스타일 파일
    /globals
      reset.css
      variables.css
    /components
      button.module.css
      
  /assets             # 정적 리소스
    /images
    /fonts
    /icons
<br>최상위에는 여전히 components, hooks, services 같은 역할별 폴더들이 있습니다. 하지만 이제 각 폴더 내부를 들여다보면 ui, product, cart 같은 도메인별 하위 폴더들이 있죠. 그리고 pages나 app 폴더는 독립적으로 존재하며 라우팅 구조를 담당합니다.<br>이런 구조에서 개발자의 사고 흐름은 대체로 이렇습니다. "장바구니에 상품을 추가하는 훅이 필요해. 그러면 hooks 폴더로 가서, cart 하위 폴더를 찾아보자." 또는 "제품 상세 페이지를 수정해야 해. pages 폴더의 products 아래에 있겠군." 역할이라는 큰 분류 아래 도메인이라는 세부 분류가 있는 이중 구조는 직관적이면서도 체계적이었습니다.<br>특히 이 구조가 인기를 얻은 이유는 점진적인 확장이 가능했기 때문입니다. 처음에는 단순히 components와 pages만으로 시작할 수 있습니다. 프로젝트가 커지면서 hooks 폴더가 추가되고, API 호출이 복잡해지면 services가 생기고, 상태 관리가 필요하면 store가 추가되는 식이죠. 각 단계에서 기존 구조를 크게 바꾸지 않고도 새로운 관심사를 수용할 수 있었습니다.<br>또한 각 폴더 내부에서도 필요에 따라 도메인별 분류를 추가할 수 있었습니다. 처음에는 모든 컴포넌트가 components 폴더에 평평하게 있다가, 파일이 많아지면 ui와 도메인별 폴더로 나누는 식이죠. 이런 유연성 덕분에 팀의 규모나 프로젝트의 복잡도에 맞춰 구조를 조정할 수 있었습니다.<br>출처: <a rel="noopener nofollow" class="external-link" href="https://velog.io/@teo/folder-structure" target="_blank">https://velog.io/@teo/folder-structure</a>]]></description><link>1.개념-정리/프레임워크-&amp;-라이브러리/폴더-구조.html</link><guid isPermaLink="false">1.개념 정리/프레임워크 &amp; 라이브러리/폴더 구조.md</guid><pubDate>Fri, 13 Jun 2025 01:47:05 GMT</pubDate></item><item><title><![CDATA[dot.daily 버튼 시스템 설계부터 적용, 문서화까지]]></title><description><![CDATA[ 
 <br><br>Next.js 기반 사이드 프로젝트 dot.daily에서 공통 UI 컴포넌트를 설계하며 class-variance-authority (cva) 기반의 버튼 시스템을 구현했습니다. 또한 Tailwind의 사용자 정의 색상과 함께 Storybook으로 문서화하여 협업 가능성과 UI 일관성을 높였습니다. 이 글은 그 흐름과 실습 내용을 정리한 기술 회고입니다.<br><br><br>
<br>✅ 다양한 버튼 스타일을 하나의 컴포넌트로 통합
<br>✅&nbsp;variant,&nbsp;size,&nbsp;rounded,&nbsp;fullWidth&nbsp;등 옵션화하여 선언형 사용 가능
<br>✅ Figma 디자인 토큰 (primary blue, text-strong 등) 반영
<br>✅ Storybook을 활용한 UI 상태 시각화 및 문서화
<br>✅ Tailwind v4 purge 이슈 해결 경험 공유
<br><br><br>
<br>Next.js (App Router)
<br>Tailwind CSS (v3)
<br>class-variance-authority (cva)
<br>Storybook
<br># 설치
npm install class-variance-authority clsx
npm install -D @storybook/nextjs
<br><br><br>처음에는 Tailwind v4 환경에서 진행했지만 다음과 같은 문제가 발생:<br>
<br>theme.extend.colors에 정의한 사용자 색상이 purge로 인해 적용되지 않음
<br>.storybook/preview.ts에 글로벌 CSS가 정상 반영되지 않음
<br><br>Tailwind를 v3로 다운그레이드:<br>npm uninstall tailwindcss
npm install -D tailwindcss@3 postcss autoprefixer
npx tailwindcss init -p
<br>📍 .storybook/preview.ts에 글로벌 CSS 적용 필수:<br>import '../src/app/globals.css';
<br><br>Tailwind 색상은 tailwind.config.ts에서 의미 기반으로 정의:<br>import colors from 'tailwindcss/colors';

theme: {
  extend: {
    colors: {
      brand: {
		primary: colors.blue[500], // 로고 강조색
		secondary: colors.indigo[500], // 보조 강조 텍스트
      },
      text: {
        strong: '#1F2937',
        weak: '#6B7280',
      },
      border: {
        default: '#E5E7EB',
      },
    },
  },
},
<br><br>CVA는  Tailwind CSS 환경에서 컴포넌트의 스타일 변형(variants) 관리를 돕는 라이브러리입니다.<br>
Tailwind Variants는 Stitches에서 영감을 받아, variants, slots, compoundVariants 등 더 복잡한 컴포넌트 구조와 반응형 스타일링을 손쉽게 관리할 수 있습니다. 반면, CVA는 단일 컴포넌트의 변형 관리에 특화되어 있으며, TypeScript와의 통합으로 타입 안전성이 뛰어납니다.<br>•	Tailwind Variants는 더 복잡한 컴포넌트(슬롯, 컴파운드 variants 등)가 필요할 때 강점이 있지만,<br>
•	dot.daily처럼 버튼, 인풋, 모달 등 단일 UI 컴포넌트 중심의 프로젝트에는 CVA가 더 심플하고 빠르게 적용할 수 있습니다.<br>
•	특히 Storybook과의 연동, 타입스크립트 기반의 안전성, 팀 협업 측면에서 CVA가 더 널리 쓰이고 있습니다.<br>✅ Storybook과 CVA의 조합은 타입 안전한 스타일 선언과 시각적 문서화를 결합해, 디자인 시스템 기반 UI 개발에 최적화된 워크플로우를 제공합니다.<br>
✅ 디자인 시스템 기반 폴더 구조는 Storybook 자체를 의미하는 것이 아니라, 컴포넌트, 스타일, 문서화 파일을 역할별로 분리해 관리하는 구조입니다.<br>
✅ Storybook은 이런 구조에서 컴포넌트의 다양한 상태와 옵션을 문서화하는 도구로 활용됩니다.<br><br>import { cva } from 'class-variance-authority';

export const buttonVariants = cva(
  'inline-flex items-center justify-center font-semibold transition whitespace-nowrap disabled:opacity-50 disabled:pointer-events-none',
  {
    variants: {
      variant: {
        /** 강조 버튼: ex) 오늘 회고 작성하기 */
        primary: 'bg-brand-primary text-white hover:bg-brand-primary/90',

        /** 보조 버튼: ex) 선택한 날짜로 이동 */
        secondary: 'bg-white text-brand-primary border border-brand-primary hover:bg-brand-primary/10',

        /** 파괴적 액션: ex) 삭제하기 */
        danger: 'bg-red-500 text-white hover:bg-red-600',

        /** 텍스트 버튼: 배경 없음 */
        ghost: 'bg-transparent text-brand-primary hover:bg-brand-primary/10',
      },
      size: {
        /** 기본 모바일 버튼 (대부분의 경우) */
        sm: 'h-9 px-3 text-sm',

        /** 피그마 기준: 보통 버튼 (예: 회고 등록하기) */
        md: 'h-10 px-4 text-base',

        /** 큰 버튼이 필요할 경우 (거의 없음) */
        lg: 'h-12 px-6 text-lg',
      },
      rounded: {
        none: '',
        md: 'rounded-md',
        full: 'rounded-full',
      },
      fullWidth: {
        true: 'w-full',
        false: '',
      },
    },
    defaultVariants: {
      variant: 'primary',
      size: 'md',
      rounded: 'full',
      fullWidth: false,
    },
  }
);
<br><br><br>&lt;Button label="오늘 회고 작성하기" variant="primary" size="md" fullWidth /&gt;
&lt;Button label="선택한 날짜로 이동" variant="secondary" size="md" fullWidth /&gt;
&lt;Button label="삭제" variant="danger" size="sm" /&gt;
&lt;Button label="로그아웃" variant="ghost" size="sm" /&gt;
<br><br><br>import { clsx } from 'clsx';
import { buttonVariants } from '@/lib/styles/buttonVariants';
import type { VariantProps } from 'class-variance-authority';

export interface ButtonProps
  extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt;,
    VariantProps&lt;typeof buttonVariants&gt; {
  label: string;
}

export const Button = ({
  label,
  variant,
  size,
  rounded,
  fullWidth,
  className,
  ...props
}: ButtonProps) =&gt; {
  return (
    &lt;button
      className={clsx(buttonVariants({ variant, size, rounded, fullWidth }), className)}
      {...props}
    &gt;
      {label}
    &lt;/button&gt;
  );
};
<br><br><br><br>export default {
  stories: ['../src/**/*.stories.@(js|ts|jsx|tsx)'],
  addons: ['@storybook/addon-links', '@storybook/addon-essentials'],
  framework: '@storybook/nextjs',
};
<br><br>import '../src/app/globals.css';
<br><br>import { Button } from './Button';

export default {
  title: 'UI/Button',
  component: Button,
};

export const Primary = {
  args: {
    label: '오늘 회고 작성하기',
    variant: 'primary',
    size: 'md',
  },
};

export const Outline = {
  args: {
    label: '선택한 날짜로 이동',
    variant: 'outline',
  },
};
<br><br><br>dot-daily/
├── public/                            # 정적 리소스 (로고, 이모지, SVG 아이콘 등)
│   └── logo.svg
│   └── icons/                         # Footer 아이콘 on/off
│
├── src/
│   ├── app/                           # Next.js App Router 기반 페이지 라우팅
│   │   ├── page.tsx                   # / (MyDay 홈)
│   │   ├── retrospect/page.tsx        # /retrospect (회고 탭)
│   │   ├── archive/page.tsx           # /archive (보류함 탭)
│   │   └── profile/page.tsx           # /profile (마이페이지 탭)
│   │
│   ├── components/                    # 공통 UI 컴포넌트 (디자인 시스템 기반)
│   │   ├── ui/
│   │   │   ├── Button.tsx             # 버튼 컴포넌트
│   │   │   ├── Button.stories.tsx     # Storybook 문서화
│   │   │   └── ...                    # Input, Modal 등 기타 공통 컴포넌트 예정
│   │   ├── layout/
│   │   │   ├── Header.tsx             # 공통 헤더 (title prop)
│   │   │   └── Footer.tsx             # 공통 푸터 (탭 이동)
│
│   ├── features/                      # 도메인 기능별 구조화
│   │   ├── myday/                     # 투두 기능 (홈)
│   │   │   ├── components/            # 도메인 전용 UI 컴포넌트
│   │   │   │   ├── TaskItem.tsx
│   │   │   │   ├── TaskList.tsx
│   │   │   │   ├── TaskInput.tsx
│   │   │   │   ├── TaskSection.tsx
│   │   │   │   └── index.ts           # barrel export
│   │   │   ├── api.ts                 # /api/tasks 관련 fetch 함수
│   │   │   ├── store.ts               # useMydayStore (Zustand 상태)
│   │   │   └── utils.ts               # 날짜 정렬/필터 등 유틸 함수
│   │   └── retrospect/                # 회고 기능 (예정)
│   │       ├── components/
│   │       ├── api.ts
│   │       ├── store.ts
│   │       └── utils.ts
│
│   ├── constants/                     # 우선순위/이모지/상태 라벨 등 공통 상수
│   │   ├── priority.ts                # PRIORITY_OPTIONS
│   │   ├── emotion.ts                 # EMOTION_TAGS
│   │   └── ...
│
│   ├── lib/
│   │   └── styles/
│   │       └── buttonVariants.ts      # class-variance-authority 기반 버튼 스타일
│
│   ├── hooks/                         # 공통 커스텀 훅 저장소 (예: useModal, useOutsideClick)
│
│   ├── styles/                        # 글로벌 CSS 및 Tailwind 설정
│   │   ├── globals.css                # tailwind base/components/utilities 포함
│
│   └── types/                         # 전역 타입 정의 (필요 시 추가)
│
├── .storybook/                       # Storybook 설정
│   ├── main.ts                        # stories 경로, addons, 프레임워크 설정
│   └── preview.ts                     # 글로벌 CSS 포함 등 환경 설정
│
├── tailwind.config.ts                # 디자인 토큰 (colors 등) 포함
├── tsconfig.json                     # 타입스크립트 설정
├── package.json
└── README.md                         # 프로젝트 소개 및 실행 방법
<br>
<br>src/app/: 라우팅 전용 (App Router 기준)
<br>components/: 공통 UI 컴포넌트 (Button, Header 등)
<br>features/: 도메인별 상태/로직/컴포넌트 분리
<br>lib/styles/buttonVariants.ts: class-variance-authority로 버튼 스타일 선언
<br>storybook/: Storybook 설정과 preview 연동
<br>constants/: 우선순위/이모지 등의 상수 정의
<br>Tailwind + 글로벌 스타일 통합: purge 문제 없이 정상 작동
<br><br><br>버튼 하나라도 디자인 시스템과 cva, Storybook을 활용해 설계하면 다음과 같은 이점이 있습니다:<br>
<br>일관된 UI/UX 유지
<br>유지보수 용이성 향상
<br>팀 간 커뮤니케이션 최소화
<br>상태 시각화 → QA/디자이너 확인 편의성
<br>향후에는 모달, 토글, 인풋 등도 이 구조로 확장 예정입니다.]]></description><link>1.개념-정리/프레임워크-&amp;-라이브러리/next.js-+-tailwind-+-storybook-기반-디자인-시스템-구축기.html</link><guid isPermaLink="false">1.개념 정리/프레임워크 &amp; 라이브러리/Next.js + Tailwind + Storybook 기반 디자인 시스템 구축기.md</guid><pubDate>Sun, 15 Jun 2025 11:04:47 GMT</pubDate></item><item><title><![CDATA[이넘, 클래스]]></title><description/></item><item><title><![CDATA[인터페이스]]></title><description><![CDATA[ 
 <br><br><br>타입스크립트에서 인터페이스는 객체 타입을 정의할 때 사용하는 문법이다.<br><br>interface User {
	name: string;
	age: number;
}

var seho: User = { name: '세호', age: 36 };
<br>인터페이스라는 예약어를 이용하여 User라는 인터페이스를 선언한 코드이다.<br>
인터페이스 속성으로 name과 age를 각각 문자열과 숫자 타입으로 정의했다.<br>
객체의 속성과 들어갈 데이터 타입을 정의하게 정의할 수 있다.<br><br>객체가 활용되는 모든 곳에 인터페이스를 쓸 수 있다.<br>
객체는 함수의 파라미터로도 사용되고 반환값으로도 사용될 수 있다.<br><br>interface Person {
	name: string;
	age: number;
}

function logAge(someone: Person) {
	console.log(somenone.age);
}

var captain = {name: 'Capt', age: 100};
logAge(captain); //100
<br>logAge()는 somenone이라는 인자를 받아 인자 안의 age 속성을 출력하는 간단한 함수이다.<br>
이 코드는 Person이라는 인터페이스를 선언한 후 logAge() 함수의 파라미터인 someone에 Person 타입을 정의한다.<br>
이름이 Capt이고 나이는 100인 객체를 captain이라는 변수에 할당하고 logAge() 함수에 넘긴 인자가 파라미터 타입을 만족하기 때문에 에러 없이 실행된다. <br><br>getPerson() 함수는 person 인터페이스 타입의 데이터를 받아 그대로 반환해 주고 있다.<br>
이 함수의 반환 타입을 명시적으로 표시하기 위해 다음과 같이 인터페이스로 함수의 반환 타입을 정의할 수 있다.<br>interface Person {
	name: string;
	age: number;
}

function getPerson(someone: Person) {
	return someone;
}

var hulk = getPerson({ name: 'hulk', age: 99 });
<br>getPerson() 함수의 호출 결과를 변수에 할당하면 다음과 같이 해당 변수가 Person 인터페이스 타입으로 추론된다.<br><br>interface Person {
	name?: string;
	age: number;
}
<br>속성을 2개 가진 객체에서 속성 1개만 필요할 때가 있다.<br>
이때 사용할 수 있는 것이 옵션 속성(optional property) 이다.<br><br>상속은 객체 간 관계 형성하는 방법이며, 상위 클래스의 내용을 하위 클래스가 물려받아 사용하거나 확장하는 기법을 의미한다.<br>
클래스를 상속받을 때 extends란 예약어를 사용했다. 인터페이스를 상속받을 때도 동일하게 extends 예약어를 사용한다. <br>interface Person {
	name: string;
	age: number;
}

interface Developer extends Person {
	skill: string;
}

var ironman: Developer = {
	name: '아이언맨',
	age: 21,
	skill: '만들기'
}
<br>Person 인터페이스를 선언하고 Developer 인터페이스에 extends로 상속한 것이다.<br>
이렇게 extends 키워드를 사용해서 인터페이스의 타입을 상속받아 확장하여 사용할 수 있고 여러번 상속을 받아서 정의할 수 있다. <br><br>var user = {
	name: '캡션',
	admin: true 
}
console.log(user['name']); //캡션

var companies = ['삼성', '네이버', '구글'];
console.log(companies[0]); //삼성
<br>user['name'] 형태로 객체의 특정 속성에 접근하거나 companies[0] 형태로 배열의 특정 요소에 접근하는 것을 인덱싱이라고한다. <br><br>interface StringArray {
	[index: number]: string;
}

var companies = ['삼성', '네이버', '구글'];
<br>StringArray 인터페이스의 속성의 [index: number] 가 어떤 숫자든 모두 속성의 이름이 될 수 있다는 의미이다.<br>
[index: number]: string; 에서 속성 이름은 숫자고 그 속성 값으로 문자열 타입이 와야한다는 의미이다.<br>
배열의 인덱스가 0이 될 수도 있고 99, 2000 등 어떤 숫자든 될 수 있기때문에 [index: number] 로 정의 한다.<br>companies[0]; //삼성
companies[2]; //구글
<br><br>interface SalaryMap {
	[level: string]: number;
}

var salary: SalaryMap = {
	junior: 100
};

var money = salary['junior'];
<br>이 SalaryMap 인터페이스는 속성 이름이 문자열 타입이고 속성 값이 숫자인 타입인 모든 속성 이름/속성 값 쌍을 허용하겠다는 의미이다. 객체의 속성에 접근하는 방법은 salary['junior'] 또는 salary.junior 모두 가능하다.<br>
다만 속성 이름에 숫자나 - 등 특수 기호가 들어가면 .junior 방식으로 접근할 수 없기 때문에 salary['junior'] 방식으로 접근해야한다.<br><br>이처럼 정확히 속성 이름을 명시하지 않고 속성 이름의 타입과 속성 값의 타입을 정의하는 문법을 인덱스 시그니처(index signature) 라고 한다. <br>interface SalaryMap {
	[level: string]: string;
}

var salary: SalaryInfo = {
	junior: '100원',
	mid: '400원',
	senior: '700원',
	ceo: '0원',
	newbie: '50원',
};
<br>단순히 객체와 배열을 인덱싱 할 때 활용될 뿐만 아니라 객체의 속성 타입을 유연하게 정의할 때도 사용된다.<br>
속성 이름이 문자열이고 속성 값의 타입이 문자열이기만 하면 1개든 100개든 모두 추가할 수 있는 장점이 생긴다.<br>interface User {
	[property: string]: string;
	id: string;
	name: string;
}

var seho: User = {
	id: '1',
	name: '세호',
	address: '판교'
};
<br>User라는 인터페이스에는 id와 name 속성이 무조건 들어간다고 한다면 섞어서 정의할 수도 있다.<br>
이처럼 객체의 속성 이른과 속성 값이 정해져 있는 경우에는 속성 이름과 속성 값 타입을 명시해서 정의하고, 속성 이름은 모르지만 속성 이름의 타입과 값의 타입을 아는 경우에는 인덱스 시그니처를 활용한다.]]></description><link>1.개념-정리/js-&amp;-ts/인터페이스.html</link><guid isPermaLink="false">1.개념 정리/JS &amp; TS/인터페이스.md</guid><pubDate>Fri, 09 May 2025 10:48:15 GMT</pubDate></item><item><title><![CDATA[타입 정의, 타입 별칭]]></title><description><![CDATA[ 
 <br><br><br><br>유니언 타입(union type)은 여러개의 타입 중 한개만 쓰고 싶을 때 사용하는 문법이다.<br>
자바스크립트의 OR 연산자의 |를 이용하여 여러개의 타입 중 1개를 사용하겠다고 선언하는 방식이 바로 유니언 타입니다.<br>function logText(text: string | number) {
	console.log(text);
}
logText('hi');
logText(100);
<br><br>유니언 타입은 다음과 같이 string과 number에서 모두 제공하는 toString()을 자동 완성할 수 있지만 any 타입은 자동 완성 되지 않는다.<br>function logText(text: string | number) {
	console.log(text.toString());  //hi
}

logText('hi');
<br><br>타입스크립트 입장에서는 함수에 인자를 넘겨 실행할 때 Person 타입이 올지 Developer 타입이 올지 알 수 없기 때문에 어느 타입이 오더라도 문제 없을 공통 속성인 name 속성만 자동 완성해준다.<br>
여기서 함수 내부에서 파라미터 타입의 종류에 따라 특정 로직을 실행하고 싶다면 다음과 같이 in 연산자를 사용해서 로직을 작성하면 된다. <br>interface Person {
	name: string;
	age: number;
}

interface Developer {
	name: string;
	skill: string;
}

function introduce(someone: Person | Developer) {
	if ('age' in someone) {
		console.log(someone.age);
		return;
	}
	if ('skill' in someone) {
		console.log(someone.skill);
		return;
	}
}

introduce({ name: 'captin', skill: 'lecture' });
<br><br><br>interface Person {
	name: string;
	age: number;
}

function logAge(someone: Person) {
	console.log(somenone.age);
}

var captain = {name: 'Capt', age: 100};
logAge(captain); //100
<br>logAge()는 somenone이라는 인자를 받아 인자 안의 age 속성을 출력하는 간단한 함수이다.<br>
이 코드는 Person이라는 인터페이스를 선언한 후 logAge() 함수의 파라미터인 someone에 Person 타입을 정의한다.<br>
이름이 Capt이고 나이는 100인 객체를 captain이라는 변수에 할당하고 logAge() 함수에 넘긴 인자가 파라미터 타입을 만족하기 때문에 에러 없이 실행된다. <br><br>getPerson() 함수는 person 인터페이스 타입의 데이터를 받아 그대로 반환해 주고 있다.<br>
이 함수의 반환 타입을 명시적으로 표시하기 위해 다음과 같이 인터페이스로 함수의 반환 타입을 정의할 수 있다.<br>interface Person {
	name: string;
	age: number;
}

function getPerson(someone: Person) {
	return someone;
}

var hulk = getPerson({ name: 'hulk', age: 99 });
<br>getPerson() 함수의 호출 결과를 변수에 할당하면 다음과 같이 해당 변수가 Person 인터페이스 타입으로 추론된다.<br><br>interface Person {
	name?: string;
	age: number;
}
<br>속성을 2개 가진 객체에서 속성 1개만 필요할 때가 있다.<br>
이때 사용할 수 있는 것이 옵션 속성(optional property) 이다.<br><br>상속은 객체 간 관계 형성하는 방법이며, 상위 클래스의 내용을 하위 클래스가 물려받아 사용하거나 확장하는 기법을 의미한다.<br>
클래스를 상속받을 때 extends란 예약어를 사용했다. 인터페이스를 상속받을 때도 동일하게 extends 예약어를 사용한다. <br>interface Person {
	name: string;
	age: number;
}

interface Developer extends Person {
	skill: string;
}

var ironman: Developer = {
	name: '아이언맨',
	age: 21,
	skill: '만들기'
}
<br>Person 인터페이스를 선언하고 Developer 인터페이스에 extends로 상속한 것이다.<br>
이렇게 extends 키워드를 사용해서 인터페이스의 타입을 상속받아 확장하여 사용할 수 있고 여러번 상속을 받아서 정의할 수 있다. ]]></description><link>1.개념-정리/js-&amp;-ts/타입-정의,-타입-별칭.html</link><guid isPermaLink="false">1.개념 정리/JS &amp; TS/타입 정의, 타입 별칭.md</guid><pubDate>Fri, 09 May 2025 10:16:53 GMT</pubDate></item><item><title><![CDATA[Node.js 기본 생태계]]></title><description><![CDATA[ 
 <br><br>Node.js는 백엔드 개발을 자바스크립트로 할 수 있게 해주는 런타임이며, 실제 개발에서는 패키지 매니저(NPM), 의존성 관리, 스크립트 실행 등 다양한 생태계 도구와 함께 사용된다.<br><br>
<br>Node.js는 브라우저가 아닌 환경에서 자바스크립트를 실행할 수 있게 해주는 런타임
<br>V8 JavaScript 엔진을 기반으로 하고 있으며, 비동기 I/O 처리에 강함
<br>주로 웹 서버, API 서버, CLI 도구 등으로 많이 사용됨
<br><br><br><br><br><br>
<br>Node.js 설치 시 함께 설치되는 기본 패키지 매니저
<br>외부 오픈소스 패키지를 설치/삭제/업데이트 가능
<br><br>npm init          # package.json 생성
npm install       # 의존성 설치
npm install &lt;pkg&gt; # 특정 패키지 설치
npm uninstall &lt;pkg&gt; # 패키지 제거
<br><br><br><br><br>npx는 Node.js 5.2 이상 버전부터 함께 제공되는 CLI 도구로,  패키지를 설치하지 않고도 한 번만 실행할 수 있도록 도와준다.<br><br><br><br>npx create-react-app my-app      # CRA 설치 없이 프로젝트 생성
npx eslint .                     # 로컬 ESLint 설치 없이 코드 검사
npx cowsay "Hello Node.js!"      # CLI 유틸 실행
<br><br><br>package.json은 Node.js 프로젝트의 메타 정보와 의존성, 실행 스크립트 등을 정의하는 설정 파일이다.<br>
프로젝트를 클론하거나 배포받았을 때, 이 파일만 있으면 npm install을 통해 동일한 환경 구축이 가능하다.<br><br><br><br>{
  "name": "my-app",
  "version": "1.0.0",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  },
  "main": "index.js",
  "license": "MIT"
}
<br><br>
<br>npm run dev처럼 scripts에 등록한 명령어를 단축 실행 가능
<br>dependencies는 운영 시 사용, devDependencies는 개발 환경에서만 사용
<br>실제 배포 시엔 --production 옵션으로 devDependencies 제외 가능
]]></description><link>1.개념-정리/node/기본-생태계.html</link><guid isPermaLink="false">1.개념 정리/Node/기본 생태계.md</guid><pubDate>Mon, 21 Apr 2025 09:56:42 GMT</pubDate></item></channel></rss>