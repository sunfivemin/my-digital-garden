---
tags:
  - TIL
created: 2025-05-23
---

# 📘 2025-05-23 TIL

## 📌 오늘 배운 핵심 요약
- Node.js에서 MySQL 쿼리를 날릴 때 흔히 사용하는 conn.query()는 직관적이지만 **에러와 유지보수 측면에서 단점**이 많다.
- conn.execute()를 사용하면 **SQL Injection을 예방**하고, **가독성과 안정성 면에서 더 좋다.**
- 하지만 모든 상황에서 execute()를 쓸 수 있는 것은 아니며, **다건 INSERT**의 경우 query()를 그대로 사용하는 것이 낫다.


## 🧠 상세 학습 내용

## 📍 주제 1: 지옥에서 온 conn.query()를 execute()로 바꾸기

기존에는 이렇게 쓰고 있었다:
```js
const sql = `INSERT INTO delivery (address, receiver, contact) VALUES (?, ?, ?)`;
const values = ['서울시 중구', '홍길동', '010-1234-5678'];
const [result] = await conn.query(sql, values);
```
이게 어떤 문제가 있느냐면…
- **예외 처리**가 직관적으로 안 된다 (콜백 스타일일 경우 특히 더 그렇다)
- 내부적으로 prepare되지 않아 **SQL Injection 위험**이 있다
- 구조가 동일해도 **자동 캐싱, 최적화**가 덜 이루어짐
  
그래서 conn.execute()로 바꾸면 다음처럼 된다:
```js
const sql = `INSERT INTO delivery (address, receiver, contact) VALUES (?, ?, ?)`;
const values = ['서울시 중구', '홍길동', '010-1234-5678'];
const [result] = await conn.execute(sql, values);
console.log(result.insertId); // 안전하게 ID 추출 가능
```

### **✅** execute() 장점 요약
- **SQL Injection 방지**: 내부적으로 prepare된 후 실행됨
- **코드가 깔끔하고 일관성 있음**
- **INSERT/UPDATE/DELETE** 같은 단일 쿼리에 매우 적합

### ✨ 그럼 query()는 이제 안 써도 돼?
아니다. 다음처럼 VALUES ? 형태의 **다건 insert**는 query()가 여전히 필요하다.
```js
const sql = `INSERT INTO orderedBook (order_id, book_id, quantity) VALUES ?`;
const values = [
  [5, 1, 2],
  [5, 2, 1],
];

await conn.query(sql, [values]); // ✅ query는 배열 bulk insert에 유리함
```
 execute()는 VALUES ? 형태에서 타입이 맞지 않아 에러가 발생할 수 있다.
 즉, 다건 데이터 insert에는 여전히 query()가 유리하다.


----

## 📍 주제 2:  테이블 DELETE, TRUNCATE, DROP 차이

### 💡 MySQL 테이블 삭제하는 방법

#### ✅ 1) DELETE – 원하는 행만 삭제
```sql
DELETE FROM 테이블명 WHERE 조건;
```
- WHERE 조건을 주면 해당 조건을 만족하는 **행만 삭제**됩니다. 
	ex) DELETE FROM orders WHERE user_id = 1;
- WHERE 없이 쓰면 테이블 안의 **모든 행이 삭제**됩니다.
- **테이블 구조와 AUTO_INCREMENT 값은 유지됨**
- 삭제된 행마다 로그를 남겨서 **속도는 느릴 수 있음**

---

#### ✅ 2) TRUNCATE – 모든 행 빠르게 삭제
```sql
TRUNCATE TABLE 테이블명;
```
- 테이블 구조는 남기고, **전체 데이터를 빠르게 삭제**합니다.
- DELETE보다 훨씬 빠르며, 내부적으로 **테이블을 DROP 후 재생성하는 방식과 유사**합니다.
- AUTO_INCREMENT 값도 초기화됨

---

#### ⚠️ 외래키(FK)가 걸려있으면 TRUNCATE가 안 된다
외래키 제약 조건이 설정된 테이블은, 다른 테이블이 이를 참조하고 있을 경우 TRUNCATE가 불가능합니다.
📛 오류 메시지 예시:
```text
Error Code: 1701. Cannot truncate a table referenced in a foreign key constraint
```

💡 **해결 방법: 외래키 체크 끄기** = SET FOREIGN_KEY_CHECKS = 0;
아래와 같은 방식으로 외래키 제약 검사를 끄고, TRUNCATE한 후 다시 켤 수 있습니다.
```sql
SET FOREIGN_KEY_CHECKS = 0;     -- 외래키 검사 끄기
TRUNCATE TABLE orders;
TRUNCATE TABLE delivery;
SET FOREIGN_KEY_CHECKS = 1;     -- 외래키 검사 다시 켜기
```

![FOREIGN_KEY_0](https://seonohblog.netlify.app/assets/FOREIGN_KEY_0.png)
![FOREIGN_KEY_1](https://seonohblog.netlify.app/assets/FOREIGN_KEY_1.png)

---

#### ✅ 3) DROP – 테이블 자체를 삭제
```sql
DROP TABLE 테이블명;
```
- **테이블 구조 자체가 삭제**되며, 복구가 어려움
- 실수로 사용하면 복구 불가능할 수 있으므로 주의 필요

#### ✨ 언제 무엇을 써야 할까?
| **상황**         | **추천 명령어**   | **이유**                  |
| -------------- | ------------ | ----------------------- |
| 특정 조건만 삭제할 때   | DELETE WHERE | 유연하게 조건 삭제 가능           |
| 전체 데이터를 초기화할 때 | TRUNCATE     | 빠르고 AUTO_INCREMENT도 초기화 |
| 테이블 자체를 없앨 때   | DROP         | 완전히 삭제하고 새로 만들 때        |


---







## 💭 회고

### • 새롭게 알게 된 점
- 

### • 어렵게 느껴졌던 부분
-

### • 다음에 학습할 주제
- 

