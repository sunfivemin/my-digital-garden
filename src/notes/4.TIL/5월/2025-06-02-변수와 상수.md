---
tags:
  - TIL
  - JavaScript
created: 2025-06-02
---
# 📘 2025-06-02 TIL

## 📌 오늘 배운 핵심 요약

C언어는 컴파일 기반의 정적 언어로서 문법이 매우 엄격하다.
• 모든 문장은 세미콜론(;)으로 끝나야 하며, 반환값(return) 개념을 통해 함수 종료를 명확하게 표현한다.
• 변수는 메모리 공간에 이름을 붙인 것이며, 우리가 직접 주소값을 다루기보단 “의미 있는 이름”을 통해 사용한다.
• 메모리는 크게 코드/스택/힙/데이터 영역으로 나뉘며, 스택은 LIFO 구조로 함수 실행 시 마다 실행 컨텍스트를 쌓고 제거하는 구조다.
• 스택과 힙의 차이를 통해 원시형과 참조형의 메모리 저장 방식을 명확히 이해할 수 있다.
• 이러한 개념은 TypeScript처럼 정적 타입 기반 언어를 이해하고 효율적으로 사용하는 데도 큰 도움이 된다.


## 🧠 상세 학습 내용

## 📍 주제 1: C 언어는 왜 문법이 엄격할까?

- 컴파일 기반 언어는 문장을 구분하기 위해 **세미콜론(;)을 반드시 붙여야** 한다.
- 컴파일러는 세미콜론을 기준으로 문장을 **단위별로 해석**한다.
- return 0;은 함수가 성공적으로 끝났다는 관례적 표현이며, 0 자체에 특별한 의미는 없다.

```c
int x = 5;      // OK
int y = 10      // ❌ 세미콜론 없음 → Syntax Error
```

💡 JS에서는 세미콜론 자동 삽입(ASI)이 있지만, C에서는 오류로 처리된다.
TypeScript도 마찬가지로 컴파일 언어로 문법이 엄격하다.
런타임 전에 타입 오류를 잡고, JavaScript로 트랜스파일되는 특징이 있다.

---

## 📍 주제 2: 변수와 자료형, 그리고 메모리

### ✅ 변수를 사용하는 이유

- 메모리는 0x1000, 0x1001 같은 주소값으로 구성되며, 사람이 외우기 어렵다.
- 따라서 의미 있는 이름(변수명)으로 주소 공간을 추상화한다.
- 예를 들어 int lucky = 7;은 주소값에 4바이트를 확보해 값을 저장하고, lucky라는 이름으로 접근한다.

### ✅ 자료형에 따라 크기가 다름

- char: 1바이트
- int: 4바이트
- double: 8바이트
→ 자료형 선언은 **메모리 공간의 확보와 해석 기준을 동시에 정의**하는 행위다.

---

## 📍 주제 3: 메모리 영역 구조

메모리는 크게 아래 네 가지로 나뉜다:

| **영역** | **역할**                  |
| ------ | ----------------------- |
| 코드 영역  | 프로그램 명령어 저장             |
| 스택 영역  | 함수 호출 시 지역변수, 매개변수 저장   |
| 힙 영역   | 개발자가 직접 할당하는 동적 메모리 저장소 |
| 데이터 영역 | 전역 변수, static 변수 저장     |
스택은 **LIFO(후입선출)** 구조로, 함수가 호출되면 메모리가 위로 쌓이고, 함수 종료 시 pop된다. eg) 급식판


---

## 📍 주제 4: 콜스택에서의 변수 저장 방식

```c
void Test(int a) {
  char b = 'A';
  int c = 1;
  double d = 3.14;
}
```
- 위 함수가 실행되면 스택에 a, b, c, d가 차례로 쌓인다.
- 자료형에 따라 크기와 순서가 달라짐 (정렬 기준에 따라 padding 발생 가능)


---

## 📍 주제 5: 원시 타입 vs 참조 타입

- 원시 타입 데이터 (int, double 등)는 값 자체가 스택에 저장된다.
- 참조 타입 데이터 (배열, 구조체 등)는 힙 메모리에 실제 값이 저장되고, 스택에는 해당 주소(포인터)만 저장된다.

```c
int a = 10;         // a는 10이라는 값을 스택에 저장
int* b = &array[0]; // b는 배열 시작 주소를 저장함
```

📌 JavaScript나 TypeScript의 메모리 구조와도 연결되며, Stack vs Heap 구조는 공통 개념이다.


---


## 💭 회고
### 새롭게 알게 된 점

- C 언어가 ‘왜’ 엄격한 문법을 갖는지 납득되었다. 문장을 구분하는 단위가 컴파일 시점에 **기계적으로 분석되어야 하기 때문**이라는 설명이 직관적으로 와닿았다.
- 또한, 스택/힙/데이터/코드 영역으로 나뉘는 메모리 구조와 각 영역의 역할을 시각적으로 이해하게 되었다.

  

###  어렵게 느껴졌던 부분

- 콜스택 구조에서 변수가 어떤 순서로 메모리에 적재되는지, 정렬 방식(padding 포함)을 고려하며 해석하는 부분이 조금 복잡했다.
- 스택과 힙 메모리의 접근 방식 차이와 변수의 주소값 개념이 처음엔 헷갈렸지만, 예제를 통해 정리할 수 있었다.

  

### 다음에 학습할 주제

- 포인터와 주소 연산자(&, *)의 동작 방식
- 타입 시스템과 TypeScript의 정적 타입 체크 방식 비교