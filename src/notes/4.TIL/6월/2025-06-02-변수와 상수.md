---
tags:
  - TIL
  - c언어
  - 타입스트립트
created: 2025-06-02
---
# 📘 2025-06-02 TIL

## 📌 오늘 배운 핵심 요약

• C언어는 컴파일 기반의 정적 언어로서 문법이 매우 엄격하다.
• 모든 문장은 세미콜론(;)으로 끝나야 하며, 반환값(return) 개념을 통해 함수 종료를 명확하게 표현한다.
• 변수는 메모리 공간에 이름을 붙인 것이며, 우리가 직접 주소값을 다루기보단 “의미 있는 이름”을 통해 사용한다.
• 메모리는 크게 코드/스택/힙/데이터 영역으로 나뉘며, 스택은 LIFO 구조로 함수 실행 시 마다 실행 컨텍스트를 쌓고 제거하는 구조다.
• 스택과 힙의 차이를 통해 원시형과 참조형의 메모리 저장 방식을 명확히 이해할 수 있다.
• 이러한 개념은 TypeScript처럼 정적 타입 기반 언어를 이해하고 효율적으로 사용하는 데도 큰 도움이 된다.


## 🧠 상세 학습 내용

## 📍 주제 1: C 언어는 왜 문법이 엄격할까?

- 컴파일 기반 언어는 문장을 구분하기 위해 **세미콜론(;)을 반드시 붙여야** 한다.
- 컴파일러는 세미콜론을 기준으로 문장을 **단위별로 해석**한다.
- return 0;은 함수가 성공적으로 끝났다는 관례적 표현이며, 0 자체에 특별한 의미는 없다.

```c
int x = 5;      // OK
int y = 10      // ❌ 세미콜론 없음 → Syntax Error
```

💡 JS에서는 세미콜론 자동 삽입(ASI)이 있지만, C에서는 오류로 처리된다.
TypeScript도 마찬가지로 컴파일 언어로 문법이 엄격하다.
런타임 전에 타입 오류를 잡고, JavaScript로 트랜스파일되는 특징이 있다.

---

## 📍 주제 2: 변수와 자료형, 그리고 메모리

### ✅ 변수를 사용하는 이유

- 메모리는 0x1000, 0x1001 같은 주소값으로 구성되며, 사람이 외우기 어렵다.
- 따라서 의미 있는 이름(변수명)으로 주소 공간을 추상화한다.
- 예를 들어 int lucky = 7;은 주소값에 4바이트를 확보해 값을 저장하고, lucky라는 이름으로 접근한다.

### ✅ 자료형에 따라 크기가 다름

- char: 1바이트
![char](https://seonohblog.netlify.app/assets/char.png)
- int: 4바이트
![int](https://seonohblog.netlify.app/assets/int.png)
- double: 8바이트
![double](https://seonohblog.netlify.app/assets/double.png)
→ 자료형 선언은 **메모리 공간의 확보와 해석 기준을 동시에 정의**하는 행위다.


---

## 📍 주제 3: 메모리 영역 구조

메모리는 크게 아래 네 가지로 나뉜다:

|**영역**|**역할**|
|---|---|
|코드 영역|프로그램의 실행 명령어가 저장되는 영역|
|스택 영역|지역 변수, 함수 매개변수가 저장되는 영역|
|힙 영역|개발자가 직접 메모리를 할당할 수 있는 영역|
|데이터 영역|전역 변수, static 변수 등이 저장되는 영역|

- 스택: LIFO 구조 → 함수가 호출되면 메모리가 위로 쌓이고, 함수 종료 시 pop된다. eg) 급식판
- 힙: 동적으로 할당되는 공간이며, 자바스크립트의 참조형 데이터 저장과 유사함


---

## 📍 주제 4: 콜스택에서의 변수 저장 방식

```c
void Test(int a) {
  char b = 'A';
  int c = 1;
  double d = 3.14;
}
```

- 함수 호출 시, 매개변수와 지역변수가 **스택 프레임(Stack Frame)** 형태로 저장된다. (스택에 a, b, c, d가 차례로 쌓인다.)
- 자료형마다 크기가 다르기 때문에 **정렬 기준에 따라 여유 공간(Padding)** 이 발생할 수 있다.

#### 🔍 padding이란?

**패딩(Padding)** 은 메모리에서 데이터를 정렬(alignment)하기 위해 **의도적으로 비워두는 공간**을 의미한다.
- 예를 들어 char(1바이트) 다음에 int(4바이트)가 온다면, 주소가 4의 배수여야 하므로 char 이후에 3바이트를 비워두고 int를 시작함.
- 이는 **CPU가 메모리를 더 빠르게 읽기 위한 구조적 정렬**이며, 공간을 낭비하더라도 성능을 우선시하는 컴퓨터 구조 때문이다.

📌 padding은 “자료형이 다르기 때문에 공간을 많이 쓰는 것”이 아니라, **정렬을 위해 비워두는 공간**이라는 점이 핵심이다.

---

## 📍 주제 5: 원시 타입 vs 참조 타입

- 원시 타입 데이터 (int, double 등)는 값 자체가 스택에 저장된다.
- 참조 타입 데이터 (배열, 구조체 등)는 힙 메모리에 실제 값이 저장되고, 스택에는 해당 주소(포인터)만 저장된다.

```c
int a = 10;         // a는 10이라는 값을 스택에 저장
int* b = &array[0]; // b는 배열 시작 주소를 저장함
```

📌 JavaScript나 TypeScript의 메모리 구조와도 연결되며, Stack vs Heap 구조는 공통 개념이다.

---

## 📍 주제 6: 상수란 무엇인가?

### ✅ 상수(const)

- **상수(const)** 는 값이 변하지 않는 메모리 공간을 의미한다.
- 변수는 메모리 공간의 값이 변경 가능하지만, 상수는 **한 번 초기화하면 값을 변경할 수 없다.**

```c
const int TEN = 10;    // ✅ 올바른 선언
TEN = 20;              // ❌ 오류: 상수는 변경 불가
```

💡 선언과 동시에 초기화하지 않으면 오류 발생! TypeScript의 const 키워드도 동일하게 작동한다.

![constError](https://seonohblog.netlify.app/assets/constError.png)



---


## 💭 회고
• **새롭게 알게 된 점**
- C 언어가 엄격한 문법을 요구하는 이유가 컴파일러가 문장을 기계적으로 해석해야 하기 때문이라는 점에서 납득이 되었다.
- padding 개념은 단순히 자료형 차이에서 오는 크기 차이로만 생각했었는데, 정렬 기준을 위한 **의도적 공백**이라는 점이 새로웠다.

• **어렵게 느껴졌던 부분**
- 스택에 저장될 때 자료형에 따라 정렬 기준이 다르고 padding이 추가되는 구조가 직관적으로 이해되지 않았다.
- 상수는 변경 불가하다는 건 알았지만, 선언 방식(const의 즉시 초기화 필수)에서 에러가 난 이유는 처음엔 몰랐다.


• **다음에 학습할 주제**
- 연산자, 분기문, 반복문
- 함수, 배열, 포인터