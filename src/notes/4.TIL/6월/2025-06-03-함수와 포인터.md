---
tags:
  - TIL
  - c언어
  - 타입스트립트
created: 2025-06-03
---
# 📘 2025-06-03 TIL

## 📌 오늘 배운 핵심 요약
- C 언어의 조건문과 반복문을 통해 흐름 제어 구조를 명확히 이해할 수 있었다.
- 이중 반복문을 활용해 구구단과 같은 2차원 출력 구조를 구현하는 방식에 익숙해졌다.
- `while`, `for`, `break`, `continue`의 사용법과 무한루프 설계 시 주의할 점을 배웠다.
- 함수의 정의, 호출 방식, 반환값 유무에 따른 차이, 특히 `void` 함수의 의미를 익혔다.
- 배열은 연속된 메모리 공간을 사용하는 자료구조이며, 문자열도 배열의 일종으로 취급된다.
- 포인터는 메모리 주소를 직접 다룰 수 있게 해주는 C 언어의 핵심 개념으로, 함수 인자 전달과 배열 처리에서 매우 중요한 역할을 한다.


## 🧠 상세 학습 내용

## 📍 주제 1: 연산자
### 💡 연산자란?
- 데이터를 계산하거나 조작하여 새로운 값을 만들어내는 도구
- 단순 숫자 연산뿐 아니라 비교, 논리적 판단까지 포함

### ✅ 연산자 종류
| **분류** | **연산자**         | **설명**     |
| ------ | --------------- | ---------- |
| 산술     | + - * / %       | 수학 계산      |
| 대입     | = += -= *= 등    | 값 할당       |
| 관계     | == != > < >= <= | 비교 연산      |
| 논리     | `&&             |            |
| 증감     | ++ --           | 값 1씩 증가/감소 |
| 비트     | `&              | ^ << >>`   |
📌 예: if (score >= 90 && score <= 100) → score가 90 이상 100 이하인 조건 체크

--- 

## 📍 주제 2: 조건문
### 💡 조건문 종류
1. if: 조건이 참일 때만 실행
2. if-else: 참일 때/거짓일 때 나눠 실행
3. if-else if: 다중 조건 분기 처리
4. 
```c
if (조건) {
  // 조건이 참일 때 실행
} else if (다른 조건) {
  // 두 번째 조건
} else {
  // 위 조건 모두 거짓일 때
}
```

### ✅ 예제
```c
int score = 85;
if (score >= 90) {
  printf("A학점");
} else if (score >= 80) {
  printf("B학점");
} else {
  printf("C학점 이하");
}
```
📌 조건은 항상 ( )로 감싸야 하며, 중괄호로 블록 범위를 명확히 표현

---

## 📍 주제 3: 반복문
### 💡 반복문의 종류
| **유형**           | **특징**                   |
| ---------------- | ------------------------ |
| while            | 조건이 참인 동안 반복             |
| do-while         | 조건 확인은 나중에 → 최소 1회 실행 보장 |
| for              | 반복 횟수가 명확할 때 사용          |
| break / continue | 반복 탈출 또는 현재 반복만 스킵       |

### ✅ while 문
```c
int i = 0;
while (i < 5) {
  printf("%d\n", i);
  i++;
}
```

### ✅ 이중 while 문
외부 while문은 단을 반복하고, 내부 while문은 곱하는 수를 반복합니다.
```c
int main() {
    int i = 2, j;
    while (i <= 9) {
        j = 1;
        while (j <= 9) {
            printf("%d * %d = %d\n", i, j, i * j);
            j++;
        }
        i++;
    }
    return 0;
}
```

### ✅ 무한 루프
무한 루프는 종료 조건 없이 **무한히 반복되는 루프**를 의미합니다. 보통 `while(1)` 또는 `for(;;)`로 작성하며, 특정 조건에서 `break`로 빠져나오게 설계해야 합니다.
```c
int main() {
    int i = 0;
    while (1) {
        printf("Programming %d\n", i);
        i++;
        if (i > 10) break; // 탈출 조건
    }
    return 0;
}
```
✅ 실제 프로그램에서는 탈출 조건 없이 무한 반복하는 루프는 CPU 점유율을 낭비하므로 반드시 **제어 흐름**을 고려해야 합니다.

### ✅ for 문
for문은 반복 횟수가 명확한 경우 매우 유용하게 쓰입니다.
```c
int main() {
    for (int i = 2; i <= 9; i++) {
        for (int j = 1; j <= 9; j++) {
            printf("%d * %d = %d\n", i, j, i * j);
        }
    }
    return 0;
}
```

### ✅ break & continue
```c
for (int i = 0; i < 5; i++) {
  if (i == 3) break;
  if (i == 1) continue;
  printf("%d ", i);
}
// 출력: 0 2
```

### ✅ while 문
```c
for (int i = 0; i < 5; i++) {
  printf("%d\n", i);
}
```

---

## 📍 주제 4: 함수와 void 
함수는 특정 기능을 모듈화한 코드 블록입니다. 
```c
자료형 함수이름(매개변수) {
    // 실행할 코드
    return 반환값;
}
```

**void 함수란?**
- `void`는 반환값이 없음을 의미합니다.
- 함수는 호출 시점에서 메모리에 로딩되어 Call Stack에 쌓였다가 실행 종료 후 제거됩니다.
- 데이터를 리턴하지 않고, 단순히 출력이나 연산을 수행할 때 사용합니다.

```c
void greet() {
    printf("Hello, world!\n");
}

int main() {
    greet(); // 함수 호출
    return 0;
}
```

📌 `void`는 "비어 있다"는 의미로, 결과값을 넘기지 않을 때 사용합니다.

---

## 📍 주제 5: 배열

배열은 **같은 자료형의 데이터를 연속된 메모리 공간에 저장**하는 자료구조입니다.

### ✅ 배열 선언
```c
int array[5];
```

- `int` : 배열 요소의 타입
- `array` : 이름
- `5` : 요소 개수 (길이)

### ✅ 메모리 구조
배열은 요소 크기(int = 4byte) * 길이 만큼의 연속된 메모리를 할당합니다.

### ✅ 배열 초기화
```c
int array[] = {1, 3, 5, 7, 9};
```

- 길이 생략 가능 → 초기값 개수로 자동 설정

![array초기화](https://seonohblog.netlify.app/assets/array초기화.png)
### ✅ 배열 복사
배열은 **통째로 복사 불가**하며, 요소 하나하나 복사해야 합니다.

```c
int arr1[5] = {1,2,3,4,5};
int arr2[5];

for(int i=0; i<5; i++) {
    arr2[i] = arr1[i];
}
```
- `arr2 = arr1;` → ❌ 컴파일 에러 발생

![array복사](https://seonohblog.netlify.app/assets/array복사.png)

### ✅ 문자열 배열과 null 문자
```c
char str[12] = "Hello World";
```

- 문자열은 문자(char)의 배열입니다.
- 마지막에는 **null 문자(\0)** 가 자동으로 추가됩니다.

### ✅ null 문자의 필요성
- 문자열의 끝을 구분하기 위해 반드시 필요
- 사람이 보기에 "Hello"는 5글자지만, 컴퓨터는 끝을 모르므로 `\0`을 통해 종료를 인식
- 그래서 실제 메모리엔 `H e l l o \0` 으로 저장됨

```c
char str[100] = "Beautiful";  // 9글자 + 1(NULL) = 10
```


---


## 📍 주제 6: 포인터 완전 정복

### 📌 포인터란?

포인터(pointer)는 **다른 변수의 메모리 주소를 저장하는 변수**이다. 즉, 포인터는 '값'이 아닌 '주소'를 다룬다. C 언어에서 메모리를 직접 다루기 위해 가장 핵심적인 개념이다.

#### ✅ 기본 개념 요약
- `*` (애스터리스크): 포인터 변수 선언 시 사용 → 예: `int *p;`
- `&` (앰퍼샌드): 변수의 주소를 가져올 때 사용 → 예: `p = &a;`
- `*p`: p가 가리키는 주소에 있는 실제 값을 의미 (역참조)

```c
int a = 10;
int *p = &a;
printf("%d", *p); // 10 출력
```

---

#### ✅ 포인터의 메모리 구조
```c
char a = 'A';     // 1 byte
int b = 100;      // 4 byte
double c = 3.14;  // 8 byte
```

메모리는 연속된 주소 공간에 저장되며, 타입에 따라 차지하는 크기가 다르다.
예를 들어, 변수 `b`가 0x02부터 시작하면 `b`는 0x02 ~ 0x05까지 4바이트를 차지한다. 이 주소값을 포인터로 접근하면 메모리를 직접 제어할 수 있다.

---

#### ✅ 포인터의 선언과 초기화
```c
int a = 10;
int *pA = &a; // pA는 a의 주소값을 저장
```

- `int *pA`는 `pA`가 `int`형 데이터를 가리키는 포인터임을 의미
- `&a`는 변수 `a`의 메모리 주소

---

#### ✅ 배열과 포인터

#### 🔹 배열 이름은 포인터다
```c
int arr[5] = {1, 2, 3, 4, 5};
```

- `arr`은 `&arr[0]`과 같으며 첫 번째 요소의 주소
- 즉 `arr`는 첫 번째 요소를 가리키는 **상수 포인터**
- `arr++` 같은 연산은 불가하다 (상수이므로)

#### 🔹 배열 요소 접근
```c
*(arr + i) == arr[i]
```
이처럼 포인터 산술 연산으로도 배열에 접근 가능하다.

---

#### ✅ 포인터와 배열 예제 (주소 출력)
```c
int arr[5] = {1,2,3,4,5};
for (int i = 0; i < 5; i++) {
  printf("arr[%d] = %d, 주소 = %p\n", i, arr[i], &arr[i]);
}
```

- 각 요소의 주소는 4바이트씩 차이난다.
- `arr` 자체의 주소는 `&arr[0]`과 같다.

---

#### ✅ 포인터를 활용한 함수 전달

#### 🔸 값에 의한 복사
```c
void Temp(int b) { b = 20; }
int main() {
  int a = 10;
  Temp(a);
  printf("%d", a); // 10
}
```

- 함수 내에서 값을 바꿔도 원본은 변경되지 않음

#### 🔸 주소에 의한 복사 (참조 전달)
```c
void Temp(int *pB) { *pB = 20; }
int main() {
  int a = 10;
  Temp(&a);
  printf("%d", a); // 20
}
```

- 함수가 포인터를 받아 직접 값을 수정함

---

#### ✅ 배열을 함수 인자로 전달할 때
```c
void func(int *pArr) {
  for(int i = 0; i < 5; i++) {
    printf("%d ", *(pArr + i));
  }
}

int main() {
  int arr[] = {1,2,3,4,5};
  func(arr); // arr == &arr[0]
}
```

- 배열은 함수에 포인터로 전달됨
- 포인터로 받아야만 올바르게 반복 접근 가능

---

#### ✅ 배열 이름과 포인터의 차이점

- 배열 이름: `arr`은 주소지만 **상수 포인터**
- 일반 포인터: `int *p = arr;`는 이후에 `p++` 가능
- 하지만 `arr++`은 컴파일 오류 → 변경 불가

---

#### ✅ 포인터 + 배열 실습 결과 예시

```c
int arr[] = {1,2,3,4,5};
printf("배열의 이름 = %p\n", arr);
printf("첫 번째 요소 주소 = %p\n", &arr[0]);
```

출력 결과:
```c
배열의 이름 = 0x7ffee1234a00
첫 번째 요소 주소 = 0x7ffee1234a00
```
→ 동일한 주소를 출력함

---

#### ✅ 함수와 포인터: 배열 전달

```c
void printArr(int *arr) {
  for(int i = 0; i < 5; i++) {
    printf("%d ", arr[i]);
  }
}
```

배열을 함수에 넘기면 **주소만 복사**된다. 즉, 참조에 의한 복사 형태로 전달된다.

#### 🧠 정리

|구분|설명|
|---|---|
|`*`|포인터 선언 및 역참조|
|`&`|주소값 획득 연산자|
|`arr`|배열 첫 요소의 주소와 같음 (상수 포인터)|
|배열 전달|함수에 주소만 전달됨 (참조 복사)|
|포인터 vs 배열 이름|배열 이름은 상수 포인터, 일반 포인터는 연산 가능|
궁극적으로 포인터는 메모리를 효율적으로 제어할 수 있게 해주는 핵심 도구이다. 특히 배열, 함수 인자 전달, 문자열 처리 등에서 중요한 역할을 한다.


---

## 💭 회고
#### • 새롭게 알게 된 점
- 단순히 반복문을 작성하는 것이 아닌, **반복 조건과 루프 제어 흐름을 의도적으로 설계**해야 함을 실감했다.
- 이중 `while`, `for`문을 활용해 **구구단 같은 2중 구조를 구현**하는 것이 처음에는 낯설었지만, 흐름도를 이해하니 반복 패턴이 자연스럽게 그려졌다.
- `void` 함수의 역할을 통해 **함수의 목적이 반드시 값을 반환하는 것만은 아니라는 점**을 알게 되었다.
- 포인터의 주소 개념이 점점 익숙해졌고, 특히 배열 이름이 포인터처럼 쓰이지만 **값을 변경할 수 없는 상수 포인터**라는 개념이 인상 깊었다.
- 함수를 통해 배열을 전달할 때 **주소만 복사되는 참조 전달 구조**를 통해 메모리 효율적인 처리 방식도 이해할 수 있었다.

#### • 어렵게 느껴졌던 부분
- 포인터가 값이 아니라 주소를 다룬다는 개념은 여전히 직관적이지 않아, 주소값 출력과 역참조 개념을 반복 학습해야 했다.
- 배열과 포인터의 관계, 특히 "배열 이름은 상수 포인터"라는 성질이 문법적으로 왜 오류를 내는지 명확히 체감하려면 더 많은 실습이 필요할 것 같다.

#### • 다음에 학습할 주제
- 함수 포인터와 구조체를 활용한 **복잡한 데이터 구조 처리**
- 동적 메모리 할당 (`malloc`, `free`)과 객체 지향 개념
- 클래스, 상속, 오버로딩/오버라이딩, 인터페이스까지 이어지는 **C 기반의 OOP 개념 확장**